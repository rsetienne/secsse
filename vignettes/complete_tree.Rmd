---
title: "Using secsse with complete phylogenies (with extinction)"
output: rmarkdown::html_vignette
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using secsse with complete phylogenies (with extinction)}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

Most current studies of evolutionary dynamics make use of molecular phylogenies,
which, for most groups, contain only information on extant species. However,
when data on extinct species is available, usually through the presence of 
fossil data, we can use complete trees. Thus, we can leverage the data
from extinct lineages for maximum-likelihood estimation with secsse.

Note that here "complete tree" should not be taken as a complete sampling 
fraction, that is, all known species being present in the phylogeny and there 
being no missing data, but rather the assumption that all currently extinct 
species are included. This follows the nomenclature of Nee et al. (1994), 
who also coined the term "reconstructed tree" for phylogenies for which there
is no information on extinct lineages.

## Set-up

Like all ML analyses with secsse, we first need a few things to start with, 
starting with a dated phylogeny. For the purpose of this vignette, we are going
to use the DDD package to simulate a complete tree, and the ape package to add
mock traits.

```{r sim_plot_tree}
library(secsse)

spec_matrix <- c(0, 0, 0, 1)
spec_matrix <- rbind(spec_matrix, c(1, 1, 1, 1))
lambda_list <- secsse::create_lambda_list(state_names = c(0, 1),
                                          num_concealed_states = 2,
                                          transition_matrix = spec_matrix,
                                          model = "CR")

mu_vector <- secsse::create_mu_vector(state_names = c(0, 1),
                                   num_concealed_states = 2,
                                   model = "CR",
                                   lambda_list = lambda_list)

shift_matrix <- c(0, 1, 3)
shift_matrix <- rbind(shift_matrix, c(1, 0, 4))

q_matrix <- secsse::create_q_matrix(state_names = c(0, 1),
                                    num_concealed_states = 2,
                                    shift_matrix = shift_matrix,
                                    diff.conceal = FALSE)


speciation_rate <- 0.5
extinction_rate <- 0.05
q_ab <- 0.1
q_ba <- 0.1
used_params <- c(speciation_rate, extinction_rate, q_ab, q_ba)

sim_lambda_list <- secsse::fill_in(lambda_list, used_params)
sim_mu_vector   <- secsse::fill_in(mu_vector, used_params)
sim_q_matrix    <- secsse::fill_in(q_matrix, used_params)

# sim_tree <- secsse::secsse_sim(lambdas = sim_lambda_list,
#                                mus = sim_mu_vector,
#                                qs = sim_q_matrix,
#                                crown_age = 5,
#                                num_concealed_states = 2,
#                                seed = 5, drop_extinct = FALSE)



```

Now that we have our phylogeny, let's specify our model. We are going to specify
the same ETD model as in the _Starting secsse_ vignette. For the full details,
consult it with `vignette("starting_secsse", package = "secsse")`.

``` {r, set-up_ETD, eval=FALSE}
spec_matrix <- c()
spec_matrix <- rbind(spec_matrix, c(0, 0, 0, 1))
spec_matrix <- rbind(spec_matrix, c(1, 1, 1, 2))
lambda_list <- secsse::create_lambda_list(state_names = c(0, 1),
                                          num_concealed_states = 2,
                                          transition_matrix = spec_matrix,
                                          model = "ETD")

mu_vec <- secsse::create_mu_vector(state_names = c(0, 1),
                                   num_concealed_states = 2,
                                   model = "ETD",
                                   lambda_list = lambda_list)

shift_matrix <- c()
shift_matrix <- rbind(shift_matrix, c(0, 1, 5))
shift_matrix <- rbind(shift_matrix, c(1, 0, 6))

q_matrix <- secsse::create_q_matrix(state_names = c(0, 1),
                                    num_concealed_states = 2,
                                    shift_matrix = shift_matrix,
                                    diff.conceal = TRUE)
q_matrix

idparsopt <- 1:8 # our maximum rate parameter was 8
idparsfix <- c(0) # we want to keep all zeros at zero
initparsopt <- rep(0.1, 8)
initparsfix <- c(0.0) # all zeros remain at zero.
sampling_fraction <- c(1, 1)

idparslist <- list()
idparslist[[1]] <- lambda_list
idparslist[[2]] <- mu_vec
idparslist[[3]] <- q_matrix
```

## Fitting the model

Finally, we run `secsse_ml()` on our complete tree, much in the same way as we 
would for one with extant species. However, this time we make sure to set the 
`is_complete_tree` argument to `TRUE` (defaults to `FALSE` if omitted). This
enables secsse to use the information present in extinct lineages.

```{r fitting_model_complete_tree, eval=FALSE}
complete_tree_ml <- secsse_ml(phy = phy,
                              traits = spec_traits,
                              num_concealed_states = 2,
                              idparslist = idparslist,
                              idparsopt = idparsopt,
                              initparsopt = initparsopt,
                              idparsfix = idparsfix,
                              parsfix = initparsfix,
                              sampling_fraction = sampling_fraction,
                              verbose = FALSE,
                              num_threads = 8,
                              is_complete_tree = TRUE)
```

Now we can see what our results look like.

```{r complete_tree_res, eval=FALSE}
complete_tree_ml_etd <- complete_tree_ml$ML
ETD_par_complete <- secsse::extract_par_vals(idparslist, complete_tree_ml$MLpars)
complete_tree_ml_etd
ETD_par_complete
spec_rates_complete <- ETD_par_complete[1:2]
ext_rates_complete <- ETD_par_complete[3:4]
Q_Examined_complete <- ETD_par_complete[5:6]
Q_Concealed_complete <- ETD_par_complete[7:8]
spec_rates_complete
ext_rates_complete
Q_Examined_complete
Q_Concealed_complete
```

## Comparing with reconstructed trees

It would be interesting to see how they compare with the same tree without any
extant species. Let's follow the standard procedure using a similar phylogeny -
the same tree we used before - but where all the extinct lineages have been 
removed. We'll keep all other model specification the same.

```{r fitting_ml_reconstructed_tree, eval=FALSE}
phy_reconstructed <- out$tes

# Grab the correct traits of the extant lineages
extant_traits <- traits[phy_reconstructed$tip.label, ]$trait

if (requireNamespace("diversitree")) {
  for_plot <- data.frame(trait = extant_traits,
                         row.names = phy_reconstructed$tip.label)
  diversitree::trait.plot(phy_reconstructed, dat = for_plot,
                          cols = list("trait" = c("blue", "red")),
                          type = "p")
}

reconstructed_tree_ml <- secsse_ml(phy = phy_reconstructed,
                                   traits = extant_traits,
                                   num_concealed_states = 2,
                                   idparslist = idparslist,
                                   idparsopt = idparsopt,
                                   initparsopt = initparsopt,
                                   idparsfix = idparsfix,
                                   parsfix = initparsfix,
                                   sampling_fraction = sampling_fraction,
                                   verbose = FALSE,
                                   num_threads = 8,
                                   is_complete_tree = FALSE)

```


```{r reconstructed_tree_res_comparison, eval=FALSE}
reconstructed_tree_ml_etd <- reconstructed_tree_ml$ML
ETD_par_reconstructed <- secsse::extract_par_vals(idparslist, reconstructed_tree_ml$MLpars)
reconstructed_tree_ml
ETD_par_reconstructed
spec_rates_reconstructed <- ETD_par_reconstructed[1:2]
ext_rates_reconstructed <- ETD_par_reconstructed[3:4]
Q_Examined_reconstructed <- ETD_par_reconstructed[5:6]
Q_Concealed_reconstructed <- ETD_par_reconstructed[7:8]

knitr::kable(data.frame(
  Reconstructed = c(spec_rates_reconstructed, ext_rates_reconstructed, Q_Examined_reconstructed, Q_Concealed_reconstructed),
    Complete = c(spec_rates_complete, ext_rates_complete, Q_Examined_complete, Q_Concealed_complete), row.names = c("Speciation rate 0", "Speciation rate 1", "Extinction rate 0", "Extinction rate 1", "Transition examined rate 0", "Transition examined rate 1", "Transition concealed rate 0", "Transition concealed rate 1")
))
```

We see that including extinct species results in higher estimated values of transition rates for the examined states, which are now also estimated to be approximately symmetrical, in contrast with the reconstructed tree. Additionally, the concealed trait transition rates are low for both traits when using the complete tree, while the reconstructed tree has a higher transition rate for concealed trait 0. Finally, and unsurprisingly, some degree of extinction is recovered when the complete tree is used.

## References

Nee S, May RM, Harvey PH. The reconstructed evolutionary process. Philos Trans R Soc Lond B Biol Sci. 1994 May 28;344(1309):305-11. doi: 10.1098/rstb.1994.0068.
