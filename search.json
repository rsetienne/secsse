[{"path":"https://rsetienne.github.io/secsse/articles/Using_secsse.html","id":"secsse-introduction","dir":"Articles","previous_headings":"","what":"SecSSE introduction","title":"Using SecSSE ML search","text":"SecSSE R package designed multistate data sets concealed state speciation (‘hisse’) framework. sense, parallel ‘MuSSE’ functionality implemented ‘diversitree’, accounts finding possible spurious relationships traits diversification rates (‘false positives’, Rabosky & Goldberg 2015) testing ‘hidden trait’ (Beaulieu et al. 2013), responsible variation diversification rates trait investigated.","code":""},{"path":"https://rsetienne.github.io/secsse/articles/Using_secsse.html","id":"secsse-input-files","dir":"Articles","previous_headings":"","what":"SecSSE input files","title":"Using SecSSE ML search","text":"good practice always remove objects memory load SecSSE: Similar ‘diversitree’ (Fitzjohn et al. 2012) ‘hisse’ (Beaulieu & O’Meara 2016) packages, SecSSE uses two input files: rooted, ultrametric tree nexus format (conversion formats nexus, refer documentation package ‘ape’) data file two columns, first containing taxa names second numeric code trait state header (usually 0,1,2,3, etc., notice ‘NA’ valid code , sure trait state assign taxon). comma-separated value file (.csv) generated MsExcel works particularly well. *.csv file can loaded R using read.csv() function. look like : data set (see bottom lines data frame) three character states labeled 1, 2 3. Notice unless want assign ambiguity states (see ), third column data file empty. Ambiguity trait state (sure trait state assign taxon , data trait state particular taxon), can assigned using ‘NA’. SecSSE handles ‘NA’ differently full trait state, assigns probabilities trait states taxon demarcated ‘NA’. second object need ultrametric phylogenetic tree, rooted labeled tips. One can load R using read.nexus(). example load prepared phylogeny named “phylo_Vign”: running SecSSE important tree tip labels agree taxon names data file, also order. purpose, run following piece code prior analysis: mismatch number taxa data tree file, receive error message. However, identify taxa causing issues tree data file, can use name.check function ‘geiger’(Harmon et al. 2008) package: taxa tree file appear trait file, worth adding value ‘NA’ trait state. done properly setting data, can proceed setting parameters constraints.","code":"rm(list = ls()) library(secsse) data(traitinfo) trait <- traitinfo tail(trait) ##     species states ## 171 out_171      2 ## 172 out_172      3 ## 173 out_173      2 ## 174 out_174      2 ## 175 out_175      3 ## 176 out_176      1 data(\"phylo_Vign\") traits <- sortingtraits(trait, phylo_Vign) library(geiger) ## Loading required package: ape ## Loading required package: phytools ## Loading required package: maps #making sure that the first line is identified as containing header info: rownames(trait) <- trait[, 1] #pick out all elements that do not agree between tree and data mismat <- name.check(phylo_Vign, trait) #this will call all taxa that are in the tree, but not the data file #mismat$tree_not_data #and conversely, #mismat$data_not_tree"},{"path":"https://rsetienne.github.io/secsse/articles/Using_secsse.html","id":"parameter-settings-and-constraints","dir":"Articles","previous_headings":"","what":"Parameter settings and constraints","title":"Using SecSSE ML search","text":"SecSSE allows implementation different models evolution, just ‘diversitree’ ‘hisse’, parameters can fixed certain values (prior information known particular values) made equal . Initial parameter values can also supplied, start maximum likelihood search . main function SecSSE package secsse_ml, performs maximum likelihood search uses input set speciation rate parameters (lambda), set extinction rate parameters (mu), matrix composed transition rates (q) various states. identifiers parameters broadly used ‘hisse’, numbers indicate examined state, whereas letters denote concealed state, 2A example examined state 2, concealed state . speciation extinction parameters supplied vectors, transition rates supplied matrix, joined list. function secsse_ml takes following arguments, PHY, TRAITS, NUM_CONCEALED_STATES, IDPARSLIST, INITPARSOPT, IDPARSOPT, IDPARSFIX, PARSFIX, COND,WEIGHTTRAITS, SAMPLING_FRACTION, TOL, METHODE, OPTIMMETHOD, bigtree. best declared outside secsse_ml function, called function. discuss chronologically: PHY: user-supplied phylogenetic tree class ‘phylo’ (see ) TRAITS: user-supplied trait data class ‘data frame’ (see ) NUM_CONCEALED_STATES: general, recommend value equal number examined states data set (way parametric complexity), however , may may computationally tractable depending size tree. alternative set value 3, advantage just three concealed states data interpretation gets lot easier. Notice value needs specified also id_paramPos. IDPARSLIST: list parameters supplied function. list contains information number parameters, well parameters interact. E.g., like speciation rates behave similarly want two transition rates identical, can set . Setting parameters argument bulk work setting model, especially number states relatively high. following visual example input parameters SecSSE, list composed three elements, one containing number parameters lambda, one mu, matrix transition rates. Notice list contains set-model parameters free, every parameter unique value, indicating parameter optimized separately. diagonal q matrix always set NA, transitions within state possible. dimensions transition matrix follow following rule: (3n)2, n number observed states. Needless say, tried running SecSSE n>10, computational practical reasons, neither probably, especially combination large trees. like speciation rate states 1B 2B , can follows: Notice one set extinction parameters , numbering used identify parameters idparslist, rather consecutive numbering referring elements within extinction parameters component idparslist: also several things can improve rate matrix reduce computational complexity. First , leave transitions state calculations simple command orders values diagonal matrix calculated. included default within idparslist, modifying q matrix way, good idea ensure diagonals still included calculations: Additionally, like set dual transitions (example state 0 1 concealed state B) 0, unlikely occur. bit matter personal preference whether , follow Beaulieu & O’Meara (2016) set dual transitions zero. One good reason simply reduce computational burden. three actions together yield following: Notice entries lambda mu vectors, well rate matrix supplied either idparsopt idparsfix, including zeros represent dual transitions (supplied idparsfix set zero parsfix. Numbers elements list can skipped without problem, long supplied correctly arguments. Q-matrices get larger, can good specify values matrices separately consecutively (matter laborious), reasons intuition. can facilitate setting idparsopt, idparsfix, initparsopt, well help setting different models (using various combinations parameter constraints) along way. piece code can copied 3-state analysis: yields following data setup: INITPARSOPT: user-supplied values parameters, vector values lambda, mu, q agree number number parameters specified model. values known beforehand, can specified follows case defined parameter set, 5 lambda’s (two equal), 6 mu’s (free), q’s (free, dual transitions): IDPARSOPT: id’s parameters want optimize (versus fixed). id’s correspond specified idparslist. example, take previously defined idparslist: want optimize speciation rate parameters, keeping rest fixed, specify following: case, values must provided extinction parameters transition rate matrix parsfix, corresponding numbers must identified idparsfix. Another example: Often want make transition rates equal. define extinctions . first define parameter list follows: optimize speciation single transition rate: IDPARSFIX: id’s parameters want fixed certain value (including zero).Notice 0 idparslist just another ID. Parallel idparsopt, following statement fix parameters associated extinction rates: Notice dual transitions set zero idparslist, . PARSFIX: specifies values parameters identified idparsfix set. number entries idparsfix (order ). example, first zero means entries idparslist ID 0 fixed zero. second zero means entries idparslist ID 10, fixed 0.0001. One can also estimate initial lambda mu values tree using simple birth-death model take account trait states. bd_ML function DDD package. good starting point q lambda/5: COND: conditioning state root. Set “maddison_cond” want conditioning done -SSE packages, “proper_cond” want use new improved conditioning. root_state_weight: SecSSe offers methods weigh probabilities states root:“proper_weights” “maddison_weights”. accompanying paper can read differences . SAMPLING_FRACTION: include sampling fraction. Sampling.f always many elements examined states, SecSSE analysis 3 states following sampling_fraction = c(0.5,0.25,0.75), half taxa state 1 sampled, quarter state two, three quarters state three. 100% known taxa state sampled, sampling_fraction=c(1,1,1). overall value known (example, know sampled 80% taxa, know distributed across states), assign value state: sampling_fraction = c(0.8,0.8,0.8). Sampling.f always placed ‘cond’ statement. TOL: basically, range values samples ML chain accepted . Typically, value tol = c(1e-04, 1e-05, 1e-07) generally best. METHODE: method integration likelihood values along branches, generally recommend “ode45”. OPTIMMETHOD: optimization method, generally recommend “simplex”. RUN_PARALLEL: specifies whether use SecSSE tree-breaking function. large tree, tree can broken two pieces computation likelihood along branches can take place simultaneously two pieces, yielding gain computation time. size two pieces established SecSSE, depends balanced tree ; better-balanced tree yields two pieces relatively equal size results relatively larger gain computation time. large trees (say, n>1000), experience even two chunks tree unequal size yield time advantage. Needless say, computational setup needs able accommodate parallel computation (multiple cores, nodes).","code":"# First we have to define idparslist, as well as, again, # a user-specified value for the number of concealed states # to be assessed by SecSSE.  idparslist <- id_paramPos(traits, num_concealed_states = 3)  #Let's take a look at the full all-free model by now simply typing  idparslist ## $lambdas ## 1A 2A 3A 1B 2B 3B 1C 2C 3C  ##  1  2  3  4  5  6  7  8  9  ##  ## $mus ## 1A 2A 3A 1B 2B 3B 1C 2C 3C  ## 10 11 12 13 14 15 16 17 18  ##  ## $Q ##    1A 2A 3A 1B 2B 3B 1C 2C 3C ## 1A NA 19 20 21 22 23 24 25 26 ## 2A 27 NA 28 29 30 31 32 33 34 ## 3A 35 36 NA 37 38 39 40 41 42 ## 1B 43 44 45 NA 46 47 48 49 50 ## 2B 51 52 53 54 NA 55 56 57 58 ## 3B 59 60 61 62 63 NA 64 65 66 ## 1C 67 68 69 70 71 72 NA 73 74 ## 2C 75 76 77 78 79 80 81 NA 82 ## 3C 83 84 85 86 87 88 89 90 NA # idparslist[[1]][c(5,6)] <- 5 #idparslist[[2]][c(1:9)] <- 7 diag(idparslist[[3]]) <- NA idparslist[[3]][1, c(5, 6, 8, 9)] <- 0 idparslist[[3]][2, c(4, 6, 7, 9)] <- 0 idparslist[[3]][3, c(4, 5, 7, 8)] <- 0 idparslist[[3]][4, c(2, 3, 8, 9)] <- 0 idparslist[[3]][5, c(1, 3, 7, 9)] <- 0 idparslist[[3]][6, c(1, 2, 7, 8)] <- 0 idparslist[[3]][7, c(2, 3, 5, 6)] <- 0 idparslist[[3]][8, c(1, 3, 4, 6)] <- 0 idparslist[[3]][9, c(1, 2, 4, 5)] <- 0 idparslist ## $lambdas ## 1A 2A 3A 1B 2B 3B 1C 2C 3C  ##  1  2  3  4  5  6  7  8  9  ##  ## $mus ## 1A 2A 3A 1B 2B 3B 1C 2C 3C  ## 10 11 12 13 14 15 16 17 18  ##  ## $Q ##    1A 2A 3A 1B 2B 3B 1C 2C 3C ## 1A NA 19 20 21  0  0 24  0  0 ## 2A 27 NA 28  0 30  0  0 33  0 ## 3A 35 36 NA  0  0 39  0  0 42 ## 1B 43  0  0 NA 46 47 48  0  0 ## 2B  0 52  0 54 NA 55  0 57  0 ## 3B  0  0 61 62 63 NA  0  0 66 ## 1C 67  0  0 70  0  0 NA 73 74 ## 2C  0 76  0  0 79  0 81 NA 82 ## 3C  0  0 85  0  0 88 89 90 NA idparslist[[3]][1, c(2)] <- 19 idparslist[[3]][1, c(3)] <- 20 idparslist[[3]][1, c(4)] <- 21 idparslist[[3]][1, c(7)] <- 22 idparslist[[3]][1, c(5, 6, 8, 9)] <- 0 idparslist[[3]][2, c(1)] <- 23 idparslist[[3]][2, c(3)] <- 24 idparslist[[3]][2, c(5)] <- 25 idparslist[[3]][2, c(8)] <- 26 idparslist[[3]][2, c(4, 6, 7, 9)] <- 0 idparslist[[3]][3, c(1)] <- 27 idparslist[[3]][3, c(2)] <- 28 idparslist[[3]][3, c(6)] <- 29 idparslist[[3]][3, c(9)] <- 30 idparslist[[3]][3, c(4, 5, 7, 8)] <- 0 idparslist[[3]][4, c(1)] <- 31 idparslist[[3]][4, c(5)] <- 32 idparslist[[3]][4, c(6)] <- 33 idparslist[[3]][4, c(7)] <- 34 idparslist[[3]][4, c(2, 3, 8, 9)] <- 0 idparslist[[3]][5, c(2)] <- 35 idparslist[[3]][5, c(4)] <- 36 idparslist[[3]][5, c(6)] <- 37 idparslist[[3]][5, c(8)] <- 38 idparslist[[3]][5, c(1, 3, 7, 9)] <- 0 idparslist[[3]][6, c(3)] <- 39 idparslist[[3]][6, c(4)] <- 40 idparslist[[3]][6, c(5)] <- 41 idparslist[[3]][6, c(9)] <- 42 idparslist[[3]][6, c(1, 2, 7, 8)] <- 0 idparslist[[3]][7, c(1)] <- 43 idparslist[[3]][7, c(4)] <- 44 idparslist[[3]][7, c(8)] <- 45 idparslist[[3]][7, c(9)] <- 46 idparslist[[3]][7, c(2, 3, 5, 6)] <- 0 idparslist[[3]][8, c(2)] <- 47 idparslist[[3]][8, c(5)] <- 48 idparslist[[3]][8, c(7)] <- 49 idparslist[[3]][8, c(9)] <- 50 idparslist[[3]][8, c(1, 3, 4, 6)] <- 0 idparslist[[3]][9, c(3)] <- 51 idparslist[[3]][9, c(6)] <- 52 idparslist[[3]][9, c(7)] <- 53 idparslist[[3]][9, c(8)] <- 54 idparslist[[3]][9, c(1, 2, 4, 5)] <- 0 diag(idparslist[[3]]) <- NA idparslist ## $lambdas ## 1A 2A 3A 1B 2B 3B 1C 2C 3C  ##  1  2  3  4  5  6  7  8  9  ##  ## $mus ## 1A 2A 3A 1B 2B 3B 1C 2C 3C  ## 10 11 12 13 14 15 16 17 18  ##  ## $Q ##    1A 2A 3A 1B 2B 3B 1C 2C 3C ## 1A NA 19 20 21  0  0 22  0  0 ## 2A 23 NA 24  0 25  0  0 26  0 ## 3A 27 28 NA  0  0 29  0  0 30 ## 1B 31  0  0 NA 32 33 34  0  0 ## 2B  0 35  0 36 NA 37  0 38  0 ## 3B  0  0 39 40 41 NA  0  0 42 ## 1C 43  0  0 44  0  0 NA 45 46 ## 2C  0 47  0  0 48  0 49 NA 50 ## 3C  0  0 51  0  0 52 53 54 NA initparsopt <- c(rep(1.2, 9), rep(0.1, 9), rep(0.25, 36)) idparslist ## $lambdas ## 1A 2A 3A 1B 2B 3B 1C 2C 3C  ##  1  2  3  4  5  6  7  8  9  ##  ## $mus ## 1A 2A 3A 1B 2B 3B 1C 2C 3C  ## 10 11 12 13 14 15 16 17 18  ##  ## $Q ##    1A 2A 3A 1B 2B 3B 1C 2C 3C ## 1A NA 19 20 21  0  0 22  0  0 ## 2A 23 NA 24  0 25  0  0 26  0 ## 3A 27 28 NA  0  0 29  0  0 30 ## 1B 31  0  0 NA 32 33 34  0  0 ## 2B  0 35  0 36 NA 37  0 38  0 ## 3B  0  0 39 40 41 NA  0  0 42 ## 1C 43  0  0 44  0  0 NA 45 46 ## 2C  0 47  0  0 48  0 49 NA 50 ## 3C  0  0 51  0  0 52 53 54 NA idparsopt <- c(1:9) #this would optimize speciation and extinction in the above setup #idparsopt <- c(1:18) idparslist[[2]][] <- 10 idparslist[[3]][1, c(2, 3, 4, 7)] <- 11 idparslist[[3]][1, c(5, 6, 8, 9)] <- 0 idparslist[[3]][2, c(1, 3, 5, 8)] <- 11 idparslist[[3]][2, c(4, 6, 7, 9)] <- 0 idparslist[[3]][3, c(1, 2, 6, 9)] <- 11 idparslist[[3]][3, c(4, 5, 7, 8)] <- 0 idparslist[[3]][4, c(1, 5, 6, 7)] <- 11 idparslist[[3]][4, c(2, 3, 8, 9)] <- 0 idparslist[[3]][5, c(2, 4, 6, 8)] <- 11 idparslist[[3]][5, c(1, 3, 7, 9)] <- 0 idparslist[[3]][6, c(3, 4, 5, 9)] <- 11 idparslist[[3]][6, c(1, 2, 7, 8)] <- 0 idparslist[[3]][7, c(1, 4, 8, 9)] <- 11 idparslist[[3]][7, c(2, 3, 5, 6)] <- 0 idparslist[[3]][8, c(2, 5, 7, 9)] <- 11 idparslist[[3]][8, c(1, 3, 4, 6)] <- 0 idparslist[[3]][9, c(3, 6, 7, 8)] <- 11 idparslist[[3]][9, c(1, 2, 4, 5)] <- 0 diag(idparslist[[3]]) <- NA idparsopt <- c(1:9, 11) idparsfix <- c(0, 10) parsfix <- c(0, 0.0001) library(DDD) startingpoint <- DDD::bd_ML(brts = ape::branching.times(phylo_Vign)) ## You are optimizing lambda0 mu0  ## You are fixing lambda1 mu1  ## Optimizing the likelihood - this may take a while.  ## The loglikelihood for the initial parameter values is -657.65168907669. ##  ## Maximum likelihood parameter estimates: lambda0: 0.066492, mu0: 0.000115, lambda1: 0.000000, mu1: 0.000000:  ## Maximum loglikelihood: -645.684269 intGuessLamba <- startingpoint$lambda0 intGuessMu <- startingpoint$mu0 #Make sure that the dimensions of initparsopt agree with those of #idparsopt. We have idparsopt <- c(1:9, 11) here, so we have 10 parameters #which correspond (look at idparslist) to 9 lambdas and 1 transition rate. #Here the transition rate is initially set at 20% (one fifth) of the initial #guess for lambda: initparsopt <- c(rep(intGuessLamba, 9), rep((intGuessLamba / 5), 1))"},{"path":"https://rsetienne.github.io/secsse/articles/Using_secsse.html","id":"running-the-likelihood-maximization","dir":"Articles","previous_headings":"","what":"Running the likelihood maximization","title":"Using SecSSE ML search","text":"defined necessary parameters running secsse_ml, can start running analysis saving R data file, example, called output.RDS. Note may take procude lot console output. following sample output, two concealed states, notice case transition rates, including dual rates, set fixed value 0.01:","code":"out <- secsse_ml(phylo_Vign,                  traits,                  num_concealed_states = 3,                  idparslist,                  idparsopt,                  initparsopt,                  idparsfix,                  parsfix,                  cond = \"maddison_cond\",                  root_state_weight = \"maddison_weights\",                  tol = c(1e-04, 1e-05, 1e-07),                  sampling_fraction = c(1, 1, 1),                  optimmethod = \"simplex\",                  num_cycles = 1)"},{"path":"https://rsetienne.github.io/secsse/articles/Using_secsse.html","id":null,"dir":"Articles","previous_headings":"","what":"Using SecSSE ML search","title":"Using SecSSE ML search","text":"","code":"#$MLpars[[1]] #          1A           2A           3A           1B           2B           3B #4.842634e-16 1.080409e-01 7.843821e-02 4.029147e-09 3.018863e-02 3.018863e-02  #$MLpars[[2]] #         1A          2A          3A          1B          2B          3B #0.002000000 0.002000109 0.002734071 0.001988593 0.002169052 0.003969142  #$MLpars[[3]] #     1A   2A   3A   1B   2B   3B #1A   NA 0.01 0.01 0.01 0.01 0.01 #2A 0.01   NA 0.01 0.01 0.01 0.01 #3A 0.01 0.01   NA 0.01 0.01 0.01 #1B 0.01 0.01 0.01   NA 0.01 0.01 #2B 0.01 0.01 0.01 0.01   NA 0.01 #3B 0.01 0.01 0.01 0.01 0.01   NA   #$ML #[1] -848.0895"},{"path":"https://rsetienne.github.io/secsse/articles/Using_secsse.html","id":null,"dir":"Articles","previous_headings":"","what":"Using SecSSE ML search","title":"Using SecSSE ML search","text":"maximum likelihood value bottom output can used model comparison.","code":""},{"path":"https://rsetienne.github.io/secsse/articles/Using_secsse.html","id":"secsse-tool-to-facilitate-composition-of-q-matrices","dir":"Articles","previous_headings":"","what":"SecSSE tool to facilitate composition of q matrices","title":"Using SecSSE ML search","text":"Often, q matrices can get quite large complicated, states analyzing. devised tool easily put together q matrices. tool starts -called ‘masterBlock’, basic matrix find information transitions examined states. information contained ‘masterBlock’ automatically mimicked inclusion full matrix, ensure complexity examined state transitions also found concealed states. use ‘masterBlock’ implies using number concealed examined states. , generating ‘masterBlock’ yields 3-state q matrix. ‘masterBlock’ can declared follows: ‘99’ example value can use populate matrix first, replaced values specify. make value conspicuously different others, can ensure skipping specification values, non-specified rates take value. ‘Ncol’ ‘nrow’ need reflect number states analyzing. first declare values diagonal ‘NA’, specify values ‘masterBlock’. values row column indicator, e.g. ‘[2,7]’ refers position 7 row 2, transition 2A 7A specifically. completing declaration ‘masterBlock’, need specify whether want variation examined states exactly concealed state (e.g. transition 1A->3A takes value 5A->5C), want concealed state additional variation account type error transition rates (total amount transition parameters concealed states examined states, values different). done : Finally, need make sure ‘masterBlock’ used baseline building transition matrix IDPARSLIST: makes final q matrix look follows: Matching amount variation rates concealed states, yields following:","code":"masterBlock <- matrix(99, ncol = 3, nrow = 3, byrow = TRUE) diag(masterBlock) <- NA masterBlock[1, 2] <- 6 masterBlock[1, 3] <- 7  masterBlock[2, 1] <- 8 masterBlock[2, 3] <- 9  masterBlock[3, 1] <- 10 masterBlock[3, 2] <- 11 diff.conceal <- FALSE myQ <- q_doubletrans(traits, masterBlock, diff.conceal) idparslist[[3]] <- myQ idparslist[[3]] ##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] ##  [1,]   NA    6    7    6    0    0    7    0    0 ##  [2,]    8   NA    9    0    6    0    0    7    0 ##  [3,]   10   11   NA    0    0    6    0    0    7 ##  [4,]    8    0    0   NA    6    7    9    0    0 ##  [5,]    0    8    0    8   NA    9    0    9    0 ##  [6,]    0    0    8   10   11   NA    0    0    9 ##  [7,]   10    0    0   11    0    0   NA    6    7 ##  [8,]    0   10    0    0   11    0    8   NA    9 ##  [9,]    0    0   10    0    0   11   10   11   NA diff.conceal <- TRUE myQ <- q_doubletrans(traits, masterBlock, diff.conceal) idparslist[[3]] <- myQ idparslist[[3]] ##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] ##  [1,]   NA    6    7   12    0    0   13    0    0 ##  [2,]    8   NA    9    0   12    0    0   13    0 ##  [3,]   10   11   NA    0    0   12    0    0   13 ##  [4,]   14    0    0   NA    6    7   15    0    0 ##  [5,]    0   14    0    8   NA    9    0   15    0 ##  [6,]    0    0   14   10   11   NA    0    0   15 ##  [7,]   16    0    0   17    0    0   NA    6    7 ##  [8,]    0   16    0    0   17    0    8   NA    9 ##  [9,]    0    0   16    0    0   17   10   11   NA"},{"path":"https://rsetienne.github.io/secsse/articles/Using_secsse.html","id":"secsse-function-to-reduce-number-of-transition-rate-parameters-by-including-multiplicative-factors","dir":"Articles","previous_headings":"","what":"SecSSE function to reduce number of transition rate parameters by including multiplicative factors","title":"Using SecSSE ML search","text":"SecSSE capability reducing computational burden decreasing number transition rate parameters inclusion multiplicative factors. Factors can also used disentangle complex patterns trait-dependent diversification multiple traits included. Suppose running analysis large number transition rate parameters, suspect linear relationships . transition lobed (L) palmate (P) feet twice infrequent palmate semi-palmate (S) feet, say P->L 2(P->S). reverse also true: L->P 2(S->P). applying factors, reducing transition matrix 6 parameters 4, models transitions concealed states allowed, reducing parameters 12 8. course, inclusion factors comes loss resolution, therefore best done parameters exact estimation essential. SecSSE, factors represented function separate secsse_ml, setup function similar secsse_ml, requires addition two parameters, SHAREFACTORS INITFACTORS. SHAREFACTORS: identifiers factors want specify. example, two factors, one governing transitions P->S one S->P. Transitions opposite directions better fixed multiplicative factor, least two needed . case specified follows: INITFACTORS: Since shared factors need initial parameter estimates, just transition parameters model , need specify . initial guesses best set 1, behave similar parameters ‘tied’ , unless good evidence (e.g. previous run) bigger smaller: Aside setting two parameters, need specify rate matrix rate parameters want governed factors. Imagine 3-state matrix, 1 refers lobed feet, 2 semi-palmate 3 palmate: Finally, run function secsse_ml_struc instead secsse_ml, make sure new parameters included. Multiplicative factors can also used connection lambdas mus, way used transition rates. Note case factors need unique across entire dataset, speciation- transition-related factors unique values shareFactors. can also used disentangle complex patterns diversification multiple traits taken account. Assume aside foot shape (example), also looking presence absence spur, like know two traits interact influence diversification. case, presence absence spur can used multiplicative factor, models can run presence absence coded multiplicative factor (.1), presence absence coded two different factors (.1,.2).","code":"#shareFactors <- c(.1, .2) #initFactors <- c(1, 1) # diag(masterBlock) <- NA # masterBlock[1, 2] <- 6 # masterBlock[1, 3] <- 6.1  #factor 1: lobed to palmate # # masterBlock[2, 1] <- 7 # masterBlock[2, 3] <- 8 # # masterBlock[3, 1] <- 7.2  #factor 2: palmate to lobed # masterBlock[3, 2] <- 9 #secsse_ml_struc(phylo_Vign..., shareFactors, initFactors)"},{"path":"https://rsetienne.github.io/secsse/articles/Using_secsse.html","id":"note-on-assigning-ambiguity-to-taxon-trait-states","dir":"Articles","previous_headings":"","what":"Note on assigning ambiguity to taxon trait states","title":"Using SecSSE ML search","text":"user wishes assign taxon multiple trait states, /unsure state best describes taxon, /can use ‘NA’. ‘NA’ used information possible state ; example state measured taxon unavailable inspection. ‘NA’ means taxon equally likely pertain state. case user information, example taxon can pertain multiple states, uncertainty regarding state one multiple states can certainty excluded, SecSSE offers flexibility handle ambiguity. case, user needs supply trait file, least four columns, one taxon name, three trait state. , show example trait info like (column species’ names removed).taxon may pertain trait state 1 3, 2, three columns least values 1 3, never 2 (species third row). hand, species fifth row can pertain states: first column 1, second 2, third 3 (although type ambiguity, easier assign ‘NA’ use single-column data file).","code":"#       traits traits traits # [1,]      2      2      2 # [2,]      1      1      1 # [3,]      2      2      2 # [4,]      3      1      1 # [5,]      1      2      3"},{"path":[]},{"path":"https://rsetienne.github.io/secsse/articles/Using_secsse.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Using SecSSE ML search","text":"Beaulieu, J. M., O’meara, B. C., & Donoghue, M. J. (2013). Identifying hidden rate changes evolution binary morphological character: evolution plant habit campanulid angiosperms. Systematic biology, 62(5), 725-737. Beaulieu, J. M., & O’Meara, B. C. (2016). Detecting hidden diversification shifts models trait-dependent speciation extinction. Systematic biology, 65(4), 583-601. FitzJohn, R. G. (2012). Diversitree: comparative phylogenetic analyses diversification R. Methods Ecology Evolution, 3(6), 1084-1092. Harmon, L. J., Weir, J. T., Brock, C. D., Glor, R. E., & Challenger, W. (2008). GEIGER: investigating evolutionary radiations. Bioinformatics, 24(1), 129-131. Rabosky, D. L., & Goldberg, E. E. (2015). Model inadequacy mistaken inferences trait-dependent speciation. Systematic Biology, 64(2), 340-355.","code":""},{"path":"https://rsetienne.github.io/secsse/articles/plotting_states.html","id":"plotting-ancestral-states","dir":"Articles","previous_headings":"","what":"Plotting ancestral states","title":"Plotting probabilities","text":", want give short (minimal) demonstration plot ancestral states alongside tree. Let us assume simple tree, almost trivial traits:  typical likelihood calculation look like (assuming 2 observed 2 hidden traits): want visualize change trait probabilities across tree, can use function ‘plot_state_exact’. use function, need provide helper function can translate posterior probabilities single probability interest. instance, 2 observed 2 hidden traits, observe following states reconstructed along nodes: , first four rows indicate tip states, whilst later three rows indicate states internal nodes (last row indicating root, case). columns indicate four extinction four speciation rates, following order params[[1]] params[[2]]. Thus, , rates 0A, 1A, 0B 1B. interested posterior probability trait 0, provide helper function sums probabilities 0A 0B, e.g.: can now use plot probability across tree. two options plotting: using evaluations along branches used integration method, evaluating branch values specific number intervals. Using explicit evaluations precies, might memory heavy. Usually, using 10-100 evaluations per branch provides accurate approximation:","code":"set.seed(5) focal_tree <- ape::rphylo(n = 4, birth = 1, death = 0) traits <- c(0, 1, 1, 0)  plot(focal_tree) params <- secsse::id_paramPos(c(0, 1), 2) params[[1]][] <- c(0.2, 0.2, 0.1, 0.1) params[[2]][] <- 0.0 params[[3]][, ] <- 0.1 diag(params[[3]]) <- NA   ll <- secsse::secsse_loglik(parameter = params,                              phy = focal_tree,                              traits = traits,                              num_concealed_states = 2,                              see_ancestral_states = TRUE,                              sampling_fraction = c(1, 1)) ll ## $ancestral_states ##        [,1]      [,2]       [,3]       [,4] ## 7 0.4243298 0.4297629 0.07433059 0.07157672 ## 6 0.1027372 0.6574616 0.03145469 0.20834647 ## 5 0.3253326 0.3253326 0.17466736 0.17466736 ##  ## $LL ## [1] -8.605749 ##  ## $states ##      [,1] [,2] [,3] [,4]      [,5]      [,6]       [,7]       [,8] ## [1,]    0    0    0    0 1.0000000 0.0000000 1.00000000 0.00000000 ## [2,]    0    0    0    0 0.0000000 1.0000000 0.00000000 1.00000000 ## [3,]    0    0    0    0 0.0000000 1.0000000 0.00000000 1.00000000 ## [4,]    0    0    0    0 1.0000000 0.0000000 1.00000000 0.00000000 ## [5,]    0    0    0    0 0.4243298 0.4297629 0.07433059 0.07157672 ## [6,]    0    0    0    0 0.1027372 0.6574616 0.03145469 0.20834647 ## [7,]    0    0    0    0 0.3253326 0.3253326 0.17466736 0.17466736 ll$states ##      [,1] [,2] [,3] [,4]      [,5]      [,6]       [,7]       [,8] ## [1,]    0    0    0    0 1.0000000 0.0000000 1.00000000 0.00000000 ## [2,]    0    0    0    0 0.0000000 1.0000000 0.00000000 1.00000000 ## [3,]    0    0    0    0 0.0000000 1.0000000 0.00000000 1.00000000 ## [4,]    0    0    0    0 1.0000000 0.0000000 1.00000000 0.00000000 ## [5,]    0    0    0    0 0.4243298 0.4297629 0.07433059 0.07157672 ## [6,]    0    0    0    0 0.1027372 0.6574616 0.03145469 0.20834647 ## [7,]    0    0    0    0 0.3253326 0.3253326 0.17466736 0.17466736 helper_function <- function(x) {   return(sum(x[c(5, 7)]) / sum(x)) # normalized by total sum, just in case. } secsse::plot_state_exact(parameters = params,                  focal_tree = focal_tree,                  traits = traits,                  num_concealed_states = 2,                  sampling_fraction = c(1, 1),                  prob_func = helper_function) ## Warning: Removed 6 rows containing missing values (`geom_segment()`). secsse::plot_state_exact(parameters = params,                  focal_tree = focal_tree,                  traits = traits,                  num_concealed_states = 2,                  sampling_fraction = c(1, 1),                  steps = 10,                  prob_func = helper_function) ## Warning: Removed 6 rows containing missing values (`geom_segment()`). secsse::plot_state_exact(parameters = params,                  focal_tree = focal_tree,                  traits = traits,                  num_concealed_states = 2,                  sampling_fraction = c(1, 1),                  steps = 100,                  prob_func = helper_function) ## Warning: Removed 6 rows containing missing values (`geom_segment()`)."},{"path":"https://rsetienne.github.io/secsse/articles/plotting_states.html","id":"using-cla-secsse","dir":"Articles","previous_headings":"","what":"Using CLA secsse","title":"Plotting probabilities","text":"CLA secsse, similar function available, works way. Borrowing example cla_secsse_loglik, first prepare parameters: , 9 different states (3 observed states, 3 hidden states), ordered regularly, e.g.: 0A, 1A, 2A, 0B, 1B, 2B, 0C, 1C, 2C. observe change state 0, formulate helper function, noticing first 9 states extinction rates: use plotting:","code":"set.seed(13) phylotree <- ape::rcoal(12, tip.label = 1:12) traits <- sample(c(0, 1, 2),                  ape::Ntip(phylotree), replace = TRUE) num_concealed_states <- 3 sampling_fraction <- c(1, 1, 1) phy <- phylotree # the idparlist for a ETD model (dual state inheritance model of evolution) # would be set like this: idparlist <- secsse::cla_id_paramPos(traits, num_concealed_states) lambd_and_modeSpe <- idparlist$lambdas lambd_and_modeSpe[1, ] <- c(1, 1, 1, 2, 2, 2, 3, 3, 3) idparlist[[1]] <- lambd_and_modeSpe idparlist[[2]][] <- 0 masterBlock <- matrix(4, ncol = 3, nrow = 3, byrow = TRUE) diag(masterBlock) <- NA idparlist[[3]] <- q_doubletrans(traits, masterBlock, diff.conceal = FALSE) # Now, internally, clasecsse sorts the lambda matrices, so they look like #  a list with 9 matrices, corresponding to the 9 states # (0A,1A,2A,0B, etc)  parameter <- idparlist lambda_and_modeSpe <- parameter$lambdas lambda_and_modeSpe[1, ] <- c(0.2, 0.2, 0.2, 0.4, 0.4, 0.4, 0.01, 0.01, 0.01) parameter[[1]] <- prepare_full_lambdas(traits, num_concealed_states, lambda_and_modeSpe) parameter[[2]] <- rep(0, 9) masterBlock <- matrix(0.07, ncol = 3, nrow = 3, byrow = TRUE) diag(masterBlock) <- NA parameter[[3]] <- q_doubletrans(traits, masterBlock, diff.conceal = FALSE) helper_function <- function(x) {   return(sum(x[c(10, 13, 16)]) / sum(x)) # normalized by total sum, just in case } secsse::plot_state_exact_cla(parameters = parameter,                              focal_tree = phy,                              traits = traits,                              num_concealed_states = 3,                              sampling_fraction = sampling_fraction,                              cond = \"maddison_cond\",                              root_state_weight = \"maddison_weights\",                              is_complete_tree = FALSE,                              prob_func = helper_function,                              steps = 10) ## Warning: Removed 22 rows containing missing values (`geom_segment()`)."},{"path":"https://rsetienne.github.io/secsse/articles/setting_up_secsse.html","id":"setting-up","dir":"Articles","previous_headings":"","what":"Setting up","title":"Setting up a secsse analysis","text":"preparing secsse analysis, can daunting prepare different required matrices settings order able perform meaningful analysis. Starting secsse package version 2.6, now general helper functions available can prepare matrices general cases. Often, general cases can already applicable, alternatively, can modified later better reflect intricacies specific studied system.","code":""},{"path":"https://rsetienne.github.io/secsse/articles/setting_up_secsse.html","id":"requirements-for-secsse-analysis","dir":"Articles","previous_headings":"","what":"Requirements for secsse analysis","title":"Setting up a secsse analysis","text":"perform secsse analysis, want use maximum likelihood find likely values parameters, given phylogenetic tree tip states. , secsse requires user specify speciation changes state daughter species relation parent species, requires user specify number unique speciation rates fitted. , explore basic example.","code":""},{"path":"https://rsetienne.github.io/secsse/articles/setting_up_secsse.html","id":"two-observed-states-two-hidden-state","dir":"Articles","previous_headings":"Requirements for secsse analysis","what":"Two observed states, two hidden state","title":"Setting up a secsse analysis","text":"start straightforward, simple case two observed states (perhaps presence / absence ornament ), assume concealed state follows similar structure, e.g. also two unique states. Now, can specify three different models, 1) constant-rates model, rates dependent trait, 2) Examined-Trait-Diversification (ETD), rates dependent observed trait 3) CTD (Concealed-Trait-Diversification), rates dependent concealed trait.","code":""},{"path":"https://rsetienne.github.io/secsse/articles/setting_up_secsse.html","id":"lambdas","dir":"Articles","previous_headings":"Requirements for secsse analysis > Two observed states, two hidden state","what":"Lambdas","title":"Setting up a secsse analysis","text":"create required lambda-matrices, need input information observed state names, number concealed states, transition_list object, matrix defining traits daughter species upon speciation associated rate. generate default transition_list, user free create (encouraged) one manually /self order reflect focal system better. assume trait labels “S” “N”, use default settings: list generated, can now use populate lambda matrices, using constant rates model assuming two concealed states (number observed states): see four lambda matrices, one combined states (e.g. combination observed hidden states). case two observed states S N, two hidden states B. results four real states SA, NA, SB NB.","code":"used_states <- c(\"S\", \"N\") focal_list <- secsse::create_default_lambda_list(state_names = used_states,                                                  model = \"CR\") focal_list ##  [,1] [,2] [,3] [,4] ##  \"S\"  \"S\"  \"S\"  \"1\"  ##  \"N\"  \"N\"  \"N\"  \"1\" num_hidden_states <- 2 lambda_matrices <- secsse::create_lambda_matrices(state_names = used_states,                                                   num_concealed_states = num_hidden_states,                                                   transition_list = focal_list,                                                   model = \"CR\") lambda_matrices ## [[1]] ##    SA NA SB NB ## SA  1  0  0  0 ## NA  0  0  0  0 ## SB  0  0  0  0 ## NB  0  0  0  0 ##  ## [[2]] ##    SA NA SB NB ## SA  0  0  0  0 ## NA  0  1  0  0 ## SB  0  0  0  0 ## NB  0  0  0  0 ##  ## [[3]] ##    SA NA SB NB ## SA  0  0  0  0 ## NA  0  0  0  0 ## SB  0  0  1  0 ## NB  0  0  0  0 ##  ## [[4]] ##    SA NA SB NB ## SA  0  0  0  0 ## NA  0  0  0  0 ## SB  0  0  0  0 ## NB  0  0  0  1"},{"path":"https://rsetienne.github.io/secsse/articles/setting_up_secsse.html","id":"extinction","dir":"Articles","previous_headings":"Requirements for secsse analysis > Two observed states, two hidden state","what":"Extinction","title":"Setting up a secsse analysis","text":"also need specify extinction rate:","code":"mus <- secsse::create_mus(state_names = used_states,                           num_concealed_states = num_hidden_states,                           model = \"CR\",                           lambdas = lambda_matrices) mus ## SA NA SB NB  ##  2  2  2  2"},{"path":"https://rsetienne.github.io/secsse/articles/setting_up_secsse.html","id":"q-matrix","dir":"Articles","previous_headings":"Requirements for secsse analysis > Two observed states, two hidden state","what":"Q matrix","title":"Setting up a secsse analysis","text":"specify q-matrix, need specify transitions using transition list. , use standard settings. , find transitions ->B, B->also S->N N->S.","code":"q_list <- secsse::create_default_q_list(state_names = used_states,                                         num_concealed_states = num_hidden_states,                                         mus = mus)  q_list ##  [,1] [,2] [,3] ##  \"S\"  \"N\"  \"3\"  ##  \"N\"  \"S\"  \"4\" trans_matrix <- secsse::create_transition_matrix(state_names = used_states,                                                  num_concealed_states = num_hidden_states,                                                  transition_list = q_list,                                                  diff.conceal = TRUE) trans_matrix ##    SA NA SB NB ## SA NA  3  5  0 ## NA  4 NA  0  5 ## SB  6  0 NA  3 ## NB  0  6  4 NA"},{"path":"https://rsetienne.github.io/secsse/articles/setting_up_secsse.html","id":"simulating-data","dir":"Articles","previous_headings":"Requirements for secsse analysis","what":"Simulating data","title":"Setting up a secsse analysis","text":"Now, can use settings perform analysis. lacking empirical data example, simulate tree . , first need specify focal rates, fill . values replaced, can now simulate “empirical” dataset:","code":"speciation <- 0.5 extinction <- 0.0 sp_sn <- 0.2 sp_ns <- 0.2 q_ab <- 0.5 q_ba <- 0.5  params <- c(speciation,             extinction,             sp_sn, sp_ns,             q_ab, q_ba)  lambda_matrices_p <- secsse::fill_in(lambda_matrices,                                      params) trans_matrix_p <- secsse::fill_in(trans_matrix,                                   params) mus_p <- secsse::fill_in(mus,                          params) simulated_tree <- secsse::secsse_sim(lambdas = lambda_matrices_p,                                      mus = mus_p,                                      qs = trans_matrix_p,                                      num_concealed_states = num_hidden_states,                                      crown_age = 5,                                      conditioning = \"obs_states\",                                      verbose = TRUE,                                      seed = 26) sim_traits <- simulated_tree$obs_traits focal_tree <- simulated_tree$phy"},{"path":"https://rsetienne.github.io/secsse/articles/setting_up_secsse.html","id":"maximum-likelihood","dir":"Articles","previous_headings":"Requirements for secsse analysis","what":"Maximum Likelihood","title":"Setting up a secsse analysis","text":"Given data, can now perform maximum likelihood analysis. , choose initialize parameters random values [0, 1], use multithreading speed analysis, use subplex optimization method, shown reliable. can now extract parameters get right place:","code":"param_posit <- list() param_posit[[1]] <- lambda_matrices param_posit[[2]] <- mus param_posit[[3]] <- trans_matrix  initpars <- params initpars <- initpars[-2]  answ <- secsse::cla_secsse_ml(phy = focal_tree,                               traits = sim_traits,                               num_concealed_states = num_hidden_states,                               idparslist = param_posit,                               idparsopt = c(1, 3, 4, 5, 6),                               initparsopt = initpars,                               idparsfix = c(0, 2),                               parsfix = c(0.0, 0.0),                               sampling_fraction = c(1, 1),                               optimmethod = \"subplex\",                               verbose = FALSE,                               num_threads = 6,                               atol = 0.1, # high values for demonstration                                rtol = 0.1) # purposes, don't use at home! ## Warning in secsse::cla_secsse_ml(phy = focal_tree, traits = sim_traits, : Note: ## you set some transitions as impossible to happen. found_pars_vals <- secsse::extract_par_vals(param_posit, answ$MLpars) found_pars_vals ## [1] 0.6105440 0.0000000 0.1472390 0.1314893 0.2108830 0.8234399"},{"path":"https://rsetienne.github.io/secsse/articles/setting_up_secsse.html","id":"comparing-models-using-aic","dir":"Articles","previous_headings":"","what":"Comparing models using AIC","title":"Setting up a secsse analysis","text":"done now CR model, can also use CTD ETD model. Let’s semi-automagically! first define generic function optimize model: can loop different models: simulated tree using CR model, expect model lowest AIC CR model , indeed find !","code":"fit_model <- function(focal_tree, traits, model) {   focal_list <- secsse::create_default_lambda_list(state_names = used_states,                                                    model = model)   lambda_matrices <- secsse::create_lambda_matrices(state_names = used_states,                                                     num_concealed_states = num_hidden_states,                                                     transition_list =                                                         focal_list,                                                     model = model)   mus <- secsse::create_mus(state_names = used_states,                             num_concealed_states = num_hidden_states,                             model = model,                             lambdas = lambda_matrices)   q_list <- secsse::create_default_q_list(state_names = used_states,                                           num_concealed_states = num_hidden_states,                                           mus = mus)    trans_matrix <- secsse::create_transition_matrix(state_names = used_states,                                                    num_concealed_states = num_hidden_states,                                                    transition_list = q_list,                                                    diff.conceal = TRUE)    param_posit <- list()   param_posit[[1]] <- lambda_matrices   param_posit[[2]] <- mus   param_posit[[3]] <- trans_matrix    max_indicator <- max(trans_matrix, na.rm = TRUE)    # we cheat a bit by setting extinction to zero -   # in a real analysis this should be avoided.   extinct_rates <- unique(mus)   idparsopt <- 1:max_indicator   idparsopt <- idparsopt[-extinct_rates]   idparsfix <- c(0, extinct_rates)   parsfix <- rep(0.0, length(idparsfix))    initpars <- c(rep(params[1], min(extinct_rates) - 1),                 params[-c(1, 2)])    answ <- secsse::cla_secsse_ml(phy = focal_tree,                                 traits = traits,                                 num_concealed_states = num_hidden_states,                                 idparslist = param_posit,                                 idparsopt = idparsopt,                                 initparsopt = initpars,                                 idparsfix = idparsfix,                                 parsfix = parsfix,                                 sampling_fraction = c(1, 1),                                 optimmethod = \"subplex\",                                 verbose = FALSE,                                 num_threads = 6,                                 atol = 0.1, # high values for demonstration                                  rtol = 0.1) # purposes, don't use at home!   found_pars_vals <- secsse::extract_par_vals(param_posit, answ$MLpars)   aic <- 2 * max_indicator - 2 * as.numeric(answ$ML)   return(list(pars = found_pars_vals,               ml = as.numeric(answ$ML),               aic = aic)) } found <- c() for (focal_model in c(\"CR\", \"CTD\", \"ETD\")) {   local_answ <- fit_model(focal_tree = focal_tree,                           traits = sim_traits,                           model = focal_model)   found <- rbind(found, c(focal_model, local_answ$ml, local_answ$aic)) } ## Warning in secsse::cla_secsse_ml(phy = focal_tree, traits = traits, ## num_concealed_states = num_hidden_states, : Note: you set some transitions as ## impossible to happen.  ## Warning in secsse::cla_secsse_ml(phy = focal_tree, traits = traits, ## num_concealed_states = num_hidden_states, : Note: you set some transitions as ## impossible to happen.  ## Warning in secsse::cla_secsse_ml(phy = focal_tree, traits = traits, ## num_concealed_states = num_hidden_states, : Note: you set some transitions as ## impossible to happen. colnames(found) <- c(\"model\", \"LL\", \"AIC\") found <- as.data.frame(found) found$LL <- as.numeric(found$LL) found$AIC <- as.numeric(found$AIC) found ##   model        LL      AIC ## 1    CR -128.1962 268.3923 ## 2   CTD -127.8295 271.6590 ## 3   ETD -127.9006 271.8012"},{"path":"https://rsetienne.github.io/secsse/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Leonel Herrera Alsina. Author. Paul van Els. Author. Thijs Janzen. Contributor. Hanno Hildenbrandt. Contributor. Pedro Santos Neves. Contributor. Rampal S. Etienne. Maintainer, author.","code":""},{"path":"https://rsetienne.github.io/secsse/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Herrera Alsina L, van Els P, Etienne R (2023). secsse: Several Examined Concealed States-Dependent Speciation Extinction. https://github.com/rsetienne/secsse, https://rsetienne.github.io/secsse/.","code":"@Manual{,   title = {secsse: Several Examined and Concealed States-Dependent Speciation and Extinction},   author = {Leonel {Herrera Alsina} and Paul {van Els} and Rampal S. Etienne},   year = {2023},   note = {https://github.com/rsetienne/secsse, https://rsetienne.github.io/secsse/}, }"},{"path":[]},{"path":"https://rsetienne.github.io/secsse/index.html","id":"what-is-secsse","dir":"","previous_headings":"","what":"What is SecSSE?","title":"Several Examined and Concealed States-Dependent Speciation and\n Extinction","text":"SecSSE R package designed multistate data sets concealed state speciation (hisse) framework. sense, parallel ‘MuSSE’ functionality implemented diversitree, accounts finding possible spurious relationships traits diversification rates (“false positives”, Rabosky & Goldberg 2015) testing “hidden trait” (Beaulieu et al. 2013), responsible variation diversification rates trait investigated.","code":""},{"path":"https://rsetienne.github.io/secsse/index.html","id":"installing-secsse","dir":"","previous_headings":"","what":"Installing secsse","title":"Several Examined and Concealed States-Dependent Speciation and\n Extinction","text":"secsse package stable version CRAN development version GitHub.","code":""},{"path":"https://rsetienne.github.io/secsse/index.html","id":"from-cran","dir":"","previous_headings":"Installing secsse","what":"From CRAN","title":"Several Examined and Concealed States-Dependent Speciation and\n Extinction","text":"within R, :","code":"install.packages(\"secsse\")"},{"path":"https://rsetienne.github.io/secsse/index.html","id":"from-github","dir":"","previous_headings":"Installing secsse","what":"From GitHub","title":"Several Examined and Concealed States-Dependent Speciation and\n Extinction","text":"Install secsse GitHub repository running:","code":"install.packages(\"remotes\") remotes::install_github(\"rsetienne/secsse\")"},{"path":[]},{"path":"https://rsetienne.github.io/secsse/index.html","id":"from-cran-1","dir":"","previous_headings":"Using secsse as a package dependency","what":"From CRAN","title":"Several Examined and Concealed States-Dependent Speciation and\n Extinction","text":"DESCRIPTION file, add secsse normal package. package directly uses secsse: package uses secsse peripherals (e.g. vignettes tests):","code":"Imports:   secsse Suggests:   secsse"},{"path":"https://rsetienne.github.io/secsse/index.html","id":"from-github-1","dir":"","previous_headings":"Using secsse as a package dependency","what":"From GitHub","title":"Several Examined and Concealed States-Dependent Speciation and\n Extinction","text":"","code":"Remotes:   rsetienne/secsse"},{"path":"https://rsetienne.github.io/secsse/index.html","id":"cite","dir":"","previous_headings":"","what":"Cite","title":"Several Examined and Concealed States-Dependent Speciation and\n Extinction","text":"use secsse publications, please cite: Herrera-Alsina, Leonel et al. “Detecting Dependence Diversification Multiple Traits Phylogenetic Trees Trait Data.” Systematic biology vol. 68,2 (2019): 317-328. https://doi.org/10.1093/sysbio/syy057","code":""},{"path":"https://rsetienne.github.io/secsse/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Several Examined and Concealed States-Dependent Speciation and\n Extinction","text":"Beaulieu, Jeremy M et al. “Identifying hidden rate changes evolution binary morphological character: evolution plant habit campanulid angiosperms.” Systematic biology vol. 62,5 (2013): 725-37. https://doi.org/.1093/sysbio/syt034 Beaulieu, Jeremy M, Brian C O’Meara. “Detecting Hidden Diversification Shifts Models Trait-Dependent Speciation Extinction.” Systematic biology vol. 65,4 (2016): 583-601. https://doi.org/10.1093/sysbio/syw022 Rabosky, Daniel L., Emma E. Goldberg. “Model inadequacy mistaken inferences trait-dependent speciation.” Systematic biology 64.2 (2015): 340-355. https://doi.org/10.1093/sysbio/syu131","code":""},{"path":"https://rsetienne.github.io/secsse/reference/cla_id_paramPos.html","id":null,"dir":"Reference","previous_headings":"","what":"Parameter structure setting for cla_secsse — cla_id_paramPos","title":"Parameter structure setting for cla_secsse — cla_id_paramPos","text":"sets parameters (speciation, extinction transition) ids. Needed ML calculation cladogenetic options (cla_secsse_ml)","code":""},{"path":"https://rsetienne.github.io/secsse/reference/cla_id_paramPos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parameter structure setting for cla_secsse — cla_id_paramPos","text":"","code":"cla_id_paramPos(traits, num_concealed_states)"},{"path":"https://rsetienne.github.io/secsse/reference/cla_id_paramPos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parameter structure setting for cla_secsse — cla_id_paramPos","text":"traits vector trait states, order states must tree tips, help, see vignette. num_concealed_states number concealed states, generally equivalent number examined states.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/cla_id_paramPos.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parameter structure setting for cla_secsse — cla_id_paramPos","text":"list includes ids parameters ML analysis.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/cla_id_paramPos.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parameter structure setting for cla_secsse — cla_id_paramPos","text":"","code":"traits <- sample(c(0,1,2), 45,replace = TRUE) #get some traits num_concealed_states <- 3 param_posit <- cla_id_paramPos(traits,num_concealed_states)"},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_eval.html","id":null,"dir":"Reference","previous_headings":"","what":"Likelihood for SecSSE model, using Rcpp — cla_secsse_eval","title":"Likelihood for SecSSE model, using Rcpp — cla_secsse_eval","text":"Using see_ancestral_states = TRUE function cla_secsse_loglik provide posterior probabilities states model nodes tree, give values branches. function evaluates probabilities fixed time intervals dt. dt fixed, may lead inaccuracies, dt best chosen small possible.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_eval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Likelihood for SecSSE model, using Rcpp — cla_secsse_eval","text":"","code":"cla_secsse_eval(   parameter,   phy,   traits,   num_concealed_states,   ancestral_states,   num_steps = NULL,   cond = \"proper_cond\",   root_state_weight = \"proper_weights\",   sampling_fraction,   setting_calculation = NULL,   loglik_penalty = 0,   is_complete_tree = FALSE,   method = \"odeint::bulirsch_stoer\",   atol = 1e-16,   rtol = 1e-16,   verbose = FALSE )"},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_eval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Likelihood for SecSSE model, using Rcpp — cla_secsse_eval","text":"parameter list first table lambdas across different modes speciation shown, second mus third  transition rates. phy phylogenetic tree class phylo, ultrametric, fully-resolved, rooted branch lengths. traits vector trait states, order states must tree tips, help, see vignette. num_concealed_states number concealed states, generally equivalent number examined states. ancestral_states ancestral states matrix provided cla_secsse_loglik, used starting points manual integration num_steps number steps integrate along branch cond condition existence node root: 'maddison_cond', 'proper_cond'(default). details, see vignette. root_state_weight method weigh states:'maddison_weigh ,'proper_weights'(default) 'equal_weights'. can also specified root state:vector c(1,0,0) indicates state 1 root state. sampling_fraction vector states sampling proportion per trait state. must many elements trait states. setting_calculation argument used internally speed calculation. leave blank (default : setting_calculation = NULL) loglik_penalty size penalty parameters; default 0 (penalty) is_complete_tree whether tree extinct species provided method integration method used, available : \"odeint::runge_kutta_cash_karp54\", \"odeint::runge_kutta_fehlberg78\", \"odeint::runge_kutta_dopri5\", \"odeint::bulirsch_stoer\" \"odeint::runge_kutta4\". Default method :\"odeint::bulirsch_stoer\". atol absolute tolerance integration rtol relative tolerance integration verbose provide intermediate verbose output TRUE","code":""},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_eval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Likelihood for SecSSE model, using Rcpp — cla_secsse_eval","text":"loglikelihood data given parameters","code":""},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_eval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Likelihood for SecSSE model, using Rcpp — cla_secsse_eval","text":"Evaluation probabilities observing states along branches.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_loglik.html","id":null,"dir":"Reference","previous_headings":"","what":"Likelihood for SecSSE model, using Rcpp — cla_secsse_loglik","title":"Likelihood for SecSSE model, using Rcpp — cla_secsse_loglik","text":"Loglikelihood calculation cla_SecSSE model given set parameters data using Rcpp","code":""},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_loglik.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Likelihood for SecSSE model, using Rcpp — cla_secsse_loglik","text":"","code":"cla_secsse_loglik(   parameter,   phy,   traits,   num_concealed_states,   cond = \"proper_cond\",   root_state_weight = \"proper_weights\",   sampling_fraction,   setting_calculation = NULL,   see_ancestral_states = FALSE,   loglik_penalty = 0,   is_complete_tree = FALSE,   num_threads = 1,   method = \"odeint::bulirsch_stoer\",   atol = 1e-08,   rtol = 1e-07 )"},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_loglik.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Likelihood for SecSSE model, using Rcpp — cla_secsse_loglik","text":"parameter list first table lambdas across different modes speciation shown, second mus third  transition rates. phy phylogenetic tree class phylo, ultrametric, fully-resolved, rooted branch lengths. traits vector trait states, order states must tree tips, help, see vignette. num_concealed_states number concealed states, generally equivalent number examined states. cond condition existence node root: 'maddison_cond', 'proper_cond'(default). details, see vignette. root_state_weight method weigh states:'maddison_weigh ,'proper_weights'(default) 'equal_weights'. can also specified root state:vector c(1,0,0) indicates state 1 root state. sampling_fraction vector states sampling proportion per trait state. must many elements trait states. setting_calculation argument used internally speed calculation. leave blank (default : setting_calculation = NULL) see_ancestral_states ancestral states shown? Deafault FALSE loglik_penalty size penalty parameters; default 0 (penalty) is_complete_tree whether tree extinct species provided num_threads number threads used, default 1. Set -1 use available threads. method integration method used, available : \"odeint::runge_kutta_cash_karp54\", \"odeint::runge_kutta_fehlberg78\", \"odeint::runge_kutta_dopri5\", \"odeint::bulirsch_stoer\" \"odeint::runge_kutta4\". Default method :\"odeint::bulirsch_stoer\". atol absolute tolerance integration rtol relative tolerance integration","code":""},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_loglik.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Likelihood for SecSSE model, using Rcpp — cla_secsse_loglik","text":"loglikelihood data given parameters","code":""},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_loglik.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Likelihood for SecSSE model, using Rcpp — cla_secsse_loglik","text":"Multithreading might lead slightly reduced accuracy (order 1e-8) therefore enabled default. Please use discretion.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_loglik.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Likelihood for SecSSE model, using Rcpp — cla_secsse_loglik","text":"","code":"rm(list=ls(all=TRUE)) library(secsse) set.seed(13) phylotree <- ape::rcoal(12, tip.label = 1:12) traits <- sample(c(0,1,2),ape::Ntip(phylotree),replace=TRUE) num_concealed_states <- 3 sampling_fraction <- c(1,1,1) phy <- phylotree # the idparlist for a ETD model (dual state inheritance model of evolution) # would be set like this: idparlist <- cla_id_paramPos(traits,num_concealed_states) lambd_and_modeSpe <- idparlist$lambdas lambd_and_modeSpe[1,] <- c(1,1,1,2,2,2,3,3,3) idparlist[[1]] <- lambd_and_modeSpe idparlist[[2]][] <- 0 masterBlock <- matrix(4,ncol=3,nrow=3,byrow=TRUE) diag(masterBlock) <- NA idparlist [[3]] <- q_doubletrans(traits,masterBlock,diff.conceal = FALSE) # Now, internally, clasecsse sorts the lambda matrices, so they look like: prepare_full_lambdas(traits,num_concealed_states,idparlist[[1]]) #> [[1]] #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #>  [1,]    1    0    0    0    0    0    0    0    0 #>  [2,]    0    0    0    0    0    0    0    0    0 #>  [3,]    0    0    0    0    0    0    0    0    0 #>  [4,]    0    0    0    0    0    0    0    0    0 #>  [5,]    0    0    0    0    0    0    0    0    0 #>  [6,]    0    0    0    0    0    0    0    0    0 #>  [7,]    0    0    0    0    0    0    0    0    0 #>  [8,]    0    0    0    0    0    0    0    0    0 #>  [9,]    0    0    0    0    0    0    0    0    0 #>  #> [[2]] #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #>  [1,]    0    0    0    0    0    0    0    0    0 #>  [2,]    0    1    0    0    0    0    0    0    0 #>  [3,]    0    0    0    0    0    0    0    0    0 #>  [4,]    0    0    0    0    0    0    0    0    0 #>  [5,]    0    0    0    0    0    0    0    0    0 #>  [6,]    0    0    0    0    0    0    0    0    0 #>  [7,]    0    0    0    0    0    0    0    0    0 #>  [8,]    0    0    0    0    0    0    0    0    0 #>  [9,]    0    0    0    0    0    0    0    0    0 #>  #> [[3]] #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #>  [1,]    0    0    0    0    0    0    0    0    0 #>  [2,]    0    0    0    0    0    0    0    0    0 #>  [3,]    0    0    1    0    0    0    0    0    0 #>  [4,]    0    0    0    0    0    0    0    0    0 #>  [5,]    0    0    0    0    0    0    0    0    0 #>  [6,]    0    0    0    0    0    0    0    0    0 #>  [7,]    0    0    0    0    0    0    0    0    0 #>  [8,]    0    0    0    0    0    0    0    0    0 #>  [9,]    0    0    0    0    0    0    0    0    0 #>  #> [[4]] #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #>  [1,]    0    0    0    0    0    0    0    0    0 #>  [2,]    0    0    0    0    0    0    0    0    0 #>  [3,]    0    0    0    0    0    0    0    0    0 #>  [4,]    0    0    0    2    0    0    0    0    0 #>  [5,]    0    0    0    0    0    0    0    0    0 #>  [6,]    0    0    0    0    0    0    0    0    0 #>  [7,]    0    0    0    0    0    0    0    0    0 #>  [8,]    0    0    0    0    0    0    0    0    0 #>  [9,]    0    0    0    0    0    0    0    0    0 #>  #> [[5]] #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #>  [1,]    0    0    0    0    0    0    0    0    0 #>  [2,]    0    0    0    0    0    0    0    0    0 #>  [3,]    0    0    0    0    0    0    0    0    0 #>  [4,]    0    0    0    0    0    0    0    0    0 #>  [5,]    0    0    0    0    2    0    0    0    0 #>  [6,]    0    0    0    0    0    0    0    0    0 #>  [7,]    0    0    0    0    0    0    0    0    0 #>  [8,]    0    0    0    0    0    0    0    0    0 #>  [9,]    0    0    0    0    0    0    0    0    0 #>  #> [[6]] #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #>  [1,]    0    0    0    0    0    0    0    0    0 #>  [2,]    0    0    0    0    0    0    0    0    0 #>  [3,]    0    0    0    0    0    0    0    0    0 #>  [4,]    0    0    0    0    0    0    0    0    0 #>  [5,]    0    0    0    0    0    0    0    0    0 #>  [6,]    0    0    0    0    0    2    0    0    0 #>  [7,]    0    0    0    0    0    0    0    0    0 #>  [8,]    0    0    0    0    0    0    0    0    0 #>  [9,]    0    0    0    0    0    0    0    0    0 #>  #> [[7]] #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #>  [1,]    0    0    0    0    0    0    0    0    0 #>  [2,]    0    0    0    0    0    0    0    0    0 #>  [3,]    0    0    0    0    0    0    0    0    0 #>  [4,]    0    0    0    0    0    0    0    0    0 #>  [5,]    0    0    0    0    0    0    0    0    0 #>  [6,]    0    0    0    0    0    0    0    0    0 #>  [7,]    0    0    0    0    0    0    3    0    0 #>  [8,]    0    0    0    0    0    0    0    0    0 #>  [9,]    0    0    0    0    0    0    0    0    0 #>  #> [[8]] #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #>  [1,]    0    0    0    0    0    0    0    0    0 #>  [2,]    0    0    0    0    0    0    0    0    0 #>  [3,]    0    0    0    0    0    0    0    0    0 #>  [4,]    0    0    0    0    0    0    0    0    0 #>  [5,]    0    0    0    0    0    0    0    0    0 #>  [6,]    0    0    0    0    0    0    0    0    0 #>  [7,]    0    0    0    0    0    0    0    0    0 #>  [8,]    0    0    0    0    0    0    0    3    0 #>  [9,]    0    0    0    0    0    0    0    0    0 #>  #> [[9]] #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #>  [1,]    0    0    0    0    0    0    0    0    0 #>  [2,]    0    0    0    0    0    0    0    0    0 #>  [3,]    0    0    0    0    0    0    0    0    0 #>  [4,]    0    0    0    0    0    0    0    0    0 #>  [5,]    0    0    0    0    0    0    0    0    0 #>  [6,]    0    0    0    0    0    0    0    0    0 #>  [7,]    0    0    0    0    0    0    0    0    0 #>  [8,]    0    0    0    0    0    0    0    0    0 #>  [9,]    0    0    0    0    0    0    0    0    3 #>  # which is a list with 9 matrices, corresponding to the 9 states # (0A,1A,2A,0B,etc) # if we want to calculate a single likelihood: parameter <- idparlist lambda_and_modeSpe <- parameter$lambdas lambda_and_modeSpe[1,] <- c(0.2,0.2,0.2,0.4,0.4,0.4,0.01,0.01,0.01) parameter[[1]] <- prepare_full_lambdas(traits,num_concealed_states, lambda_and_modeSpe) parameter[[2]] <- rep(0,9) masterBlock <- matrix(0.07, ncol=3, nrow=3, byrow=TRUE) diag(masterBlock) <- NA parameter [[3]] <- q_doubletrans(traits,masterBlock,diff.conceal = FALSE) cla_secsse_loglik(parameter, phy, traits, num_concealed_states,                  cond = 'maddison_cond',                  root_state_weight = 'maddison_weights', sampling_fraction,                  setting_calculation = NULL,                  see_ancestral_states = FALSE,                  loglik_penalty = 0) #> [1] -42.18407 # LL = -42.18407"},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_ml.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum likehood estimation for (SecSSE) — cla_secsse_ml","title":"Maximum likehood estimation for (SecSSE) — cla_secsse_ml","text":"Maximum likehood estimation Several examined concealed States-dependent Speciation Extinction (SecSSE) cladogenetic option","code":""},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_ml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum likehood estimation for (SecSSE) — cla_secsse_ml","text":"","code":"cla_secsse_ml(   phy,   traits,   num_concealed_states,   idparslist,   idparsopt,   initparsopt,   idparsfix,   parsfix,   cond = \"proper_cond\",   root_state_weight = \"proper_weights\",   sampling_fraction,   tol = c(1e-04, 1e-05, 1e-07),   maxiter = 1000 * round((1.25)^length(idparsopt)),   optimmethod = \"subplex\",   num_cycles = 1,   loglik_penalty = 0,   is_complete_tree = FALSE,   verbose = (optimmethod == \"subplex\"),   num_threads = 1,   atol = 1e-08,   rtol = 1e-07,   method = \"odeint::bulirsch_stoer\" )"},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_ml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum likehood estimation for (SecSSE) — cla_secsse_ml","text":"phy phylogenetic tree class phylo, ultrametric, rooted branch lengths. traits vector trait states tip phylogeny. num_concealed_states number concealed states, generally equivalent number examined states dataset. idparslist overview parameters values. idparsopt id parameters estimated. initparsopt initial guess parameters estimated. idparsfix id fixed parameters. parsfix value fixed parameters. cond condition existence node root: 'maddison_cond', 'proper_cond'(default). details, see vignette. root_state_weight method weigh states: 'maddison_weights','proper_weights'(default) 'equal_weights'. can also specified root state:vector c(1,0,0) indicates state 1 root state. sampling_fraction vector states sampling proportion per trait state. must many elements trait states. tol maximum tolerance. Default 'c(1e-04, 1e-05, 1e-05)'. maxiter max number iterations. Default '1000*round((1.25)^length(idparsopt))'. optimmethod method used optimization. Available simplex subplex, default 'subplex'. Simplex used debugging. num_cycles number cycles optimization (default 1). loglik_penalty size penalty parameters; default 0 (penalty) is_complete_tree whether tree extinct species provided verbose sets verbose output; default verbose optimmethod 'subplex' num_threads number threads. Set -1 use available threads. Default one thread. atol absolute tolerance integration rtol relative tolerance integration method integration method used, available : \"odeint::runge_kutta_cash_karp54\", \"odeint::runge_kutta_fehlberg78\", \"odeint::runge_kutta_dopri5\", \"odeint::bulirsch_stoer\" \"odeint::runge_kutta4\". Default method :\"odeint::bulirsch_stoer\".","code":""},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_ml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maximum likehood estimation for (SecSSE) — cla_secsse_ml","text":"Parameter estimated maximum likelihood","code":""},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_ml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximum likehood estimation for (SecSSE) — cla_secsse_ml","text":"","code":"# Example of how to set the arguments for a ML search. library(secsse) library(DDD) set.seed(13) # Check the vignette for a better working exercise. # lambdas for 0A and 1A and 2A are the same but need to be estimated # (CTD model, see Syst Biol paper) # mus are fixed to zero, # the transition rates are constrained to be equal and fixed 0.01 phylotree <- ape::rcoal(31, tip.label = 1:31) #get some traits traits <-  sample(c(0,1,2), ape::Ntip(phylotree), replace = TRUE) num_concealed_states <- 3 idparslist <- cla_id_paramPos(traits,num_concealed_states) idparslist$lambdas[1,] <- c(1,1,1,2,2,2,3,3,3) idparslist[[2]][] <- 4 masterBlock <- matrix(5,ncol = 3,nrow = 3,byrow = TRUE) diag(masterBlock) <- NA diff.conceal <- FALSE idparslist[[3]] <- q_doubletrans(traits,masterBlock,diff.conceal) startingpoint <- bd_ML(brts = ape::branching.times(phylotree)) #> You are optimizing lambda0 mu0  #> You are fixing lambda1 mu1  #> Optimizing the likelihood - this may take a while.  #> The loglikelihood for the initial parameter values is -67.5669039297515. #>  #> Maximum likelihood parameter estimates: lambda0: 15.604290, mu0: 15.874464, lambda1: 0.000000, mu1: 0.000000:  #> Maximum loglikelihood: 25.282018 intGuessLamba <- startingpoint$lambda0 intGuessMu <- startingpoint$mu0 idparsopt <- c(1,2,3) initparsopt <- c(rep(intGuessLamba,3)) idparsfix <- c(0,4,5) parsfix <- c(0,0,0.01) tol <- c(1e-04, 1e-05, 1e-07) maxiter <- 1000 * round((1.25) ^ length(idparsopt)) optimmethod <- 'subplex' cond <- 'proper_cond' root_state_weight <- 'proper_weights' sampling_fraction <- c(1,1,1) model <- cla_secsse_ml(  phylotree,  traits,  num_concealed_states,  idparslist,  idparsopt,  initparsopt,  idparsfix,  parsfix,  cond,  root_state_weight,  sampling_fraction,  tol,  maxiter,  optimmethod,  num_cycles = 1,  verbose = FALSE) #> Warning: Note: you set some transitions as impossible to happen. # [1] -90.97626"},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_ml_func_def_pars.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum likehood estimation for (SecSSE) with parameter as complex\nfunctions. Cladogenetic version — cla_secsse_ml_func_def_pars","title":"Maximum likehood estimation for (SecSSE) with parameter as complex\nfunctions. Cladogenetic version — cla_secsse_ml_func_def_pars","text":"Maximum likehood estimation cla Several examined concealed States-dependent Speciation Extinction (SecSSE) paramaters functions parameters /factors. Offers option cladogenesis","code":""},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_ml_func_def_pars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum likehood estimation for (SecSSE) with parameter as complex\nfunctions. Cladogenetic version — cla_secsse_ml_func_def_pars","text":"","code":"cla_secsse_ml_func_def_pars(   phy,   traits,   num_concealed_states,   idparslist,   idparsopt,   initparsopt,   idfactorsopt,   initfactors,   idparsfix,   parsfix,   idparsfuncdefpar,   functions_defining_params,   cond = \"proper_cond\",   root_state_weight = \"proper_weights\",   sampling_fraction,   tol = c(1e-04, 1e-05, 1e-07),   maxiter = 1000 * round((1.25)^length(idparsopt)),   optimmethod = \"simplex\",   num_cycles = 1,   loglik_penalty = 0,   is_complete_tree = FALSE,   verbose = (optimmethod == \"subplex\"),   num_threads = 1,   atol = 1e-12,   rtol = 1e-12,   method = \"odeint::bulirsch_stoer\" )"},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_ml_func_def_pars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum likehood estimation for (SecSSE) with parameter as complex\nfunctions. Cladogenetic version — cla_secsse_ml_func_def_pars","text":"phy phylogenetic tree class phylo, ultrametric, rooted branch lengths. traits vector trait states tip phylogeny. num_concealed_states number concealed states, generally equivalent number examined states dataset. idparslist overview parameters values. idparsopt id parameters estimated. initparsopt initial guess parameters estimated. idfactorsopt id factors optimized. fixed factors, use constant within 'functions_defining_params'. initfactors initial guess factor (set NULL factors). idparsfix id fixed parameters (set NULL factors). parsfix value fixed parameters. idparsfuncdefpar id parameters function optimized /fixed parameters. order id match functions_defining_params functions_defining_params list functions. element function defines parameter e.g. id_3 <- (id_1+id_2)/2. See example vigenette cond condition existence node root: 'maddison_cond', 'proper_cond'(default). details, see vignette. root_state_weight method weigh states:'maddison_weights', 'proper_weights'(default) 'equal_weights'. can also specified root state:vector c(1,0,0) indicates state 1 root state. sampling_fraction vector states sampling proportion per trait state. must many elements trait states. tol maximum tolerance. Default 'c(1e-04, 1e-05, 1e-05)'. maxiter max number iterations. Default '1000*round((1.25)^length(idparsopt))'. optimmethod method used optimization. Default 'simplex'. num_cycles number cycles optimization (default 1). loglik_penalty size penalty parameters; default 0 (penalty) is_complete_tree whether tree extinct species provided verbose sets verbose output; default verbose optimmethod 'subplex' num_threads number threads. Set -1 use available threads. Default one thread. atol absolute tolerance integration rtol relative tolerance integration method integration method used, available : \"odeint::runge_kutta_cash_karp54\", \"odeint::runge_kutta_fehlberg78\", \"odeint::runge_kutta_dopri5\", \"odeint::bulirsch_stoer\" \"odeint::runge_kutta4\". Default method :\"odeint::bulirsch_stoer\".","code":""},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_ml_func_def_pars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maximum likehood estimation for (SecSSE) with parameter as complex\nfunctions. Cladogenetic version — cla_secsse_ml_func_def_pars","text":"Parameter estimated maximum likelihood Parameter estimated maximum likelihood","code":""},{"path":"https://rsetienne.github.io/secsse/reference/cla_secsse_ml_func_def_pars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximum likehood estimation for (SecSSE) with parameter as complex\nfunctions. Cladogenetic version — cla_secsse_ml_func_def_pars","text":"","code":"# Example of how to set the arguments for a ML search. rm(list=ls(all=TRUE)) library(secsse) library(DDD) set.seed(16) phylotree <- ape::rbdtree(0.07,0.001,Tmax=50) startingpoint <- bd_ML(brts = ape::branching.times(phylotree)) #> You are optimizing lambda0 mu0  #> You are fixing lambda1 mu1  #> Optimizing the likelihood - this may take a while.  #> The loglikelihood for the initial parameter values is -106.425581129189. #>  #> Maximum likelihood parameter estimates: lambda0: 0.056537, mu0: 0.000000, lambda1: 0.000000, mu1: 0.000000:  #> Maximum loglikelihood: -104.592844 intGuessLamba <- startingpoint$lambda0 intGuessMu <- startingpoint$mu0 traits <-  sample(c(0,1,2),                  ape::Ntip(phylotree), replace = TRUE) # get some traits num_concealed_states <- 3 idparslist <- cla_id_paramPos(traits, num_concealed_states) idparslist$lambdas[1,] <- c(1,2,3,1,2,3,1,2,3) idparslist[[2]][] <- 4 masterBlock <- matrix(c(5,6,5,6,5,6,5,6,5),ncol = 3, nrow=3, byrow = TRUE) diag(masterBlock) <- NA diff.conceal <- FALSE idparslist[[3]] <- q_doubletrans(traits,masterBlock,diff.conceal) idparsfuncdefpar <- c(3,5,6) idparsopt <- c(1,2) idparsfix <- c(0,4) initparsopt <- c(rep(intGuessLamba,2)) parsfix <- c(0,0) idfactorsopt <- 1 initfactors <- 4 # functions_defining_params is a list of functions. Each function has no # arguments and to refer # to parameters ids should be indicated as 'par_' i.e. par_3 refers to # parameter 3. When a # function is defined, be sure that all the parameters involved are either # estimated, fixed or # defined by previous functions (i.e, a function that defines parameter in # 'functions_defining_params'). The user is responsible for this. In this # example, par_3 # (i.e., parameter 3) is needed to calculate par_6. This is correct because # par_3 is defined # in the first function of 'functions_defining_params'. Notice that factor_1 # indicates a value # that will be estimated to satisfy the equation. The same factor can be # shared to define several parameters. functions_defining_params <- list() functions_defining_params[[1]] <- function() {  par_3 <- par_1 + par_2 } functions_defining_params[[2]] <- function() {  par_5 <- par_1 * factor_1 } functions_defining_params[[3]] <- function() {  par_6 <- par_3 * factor_1 }  tol = c(1e-02, 1e-03, 1e-04) maxiter = 1000 * round((1.25)^length(idparsopt)) optimmethod = 'subplex' cond <- 'proper_cond' root_state_weight <- 'proper_weights' sampling_fraction <- c(1,1,1) model <- cla_secsse_ml_func_def_pars(phylotree, traits, num_concealed_states, idparslist, idparsopt, initparsopt, idfactorsopt, initfactors, idparsfix, parsfix, idparsfuncdefpar, functions_defining_params, cond, root_state_weight, sampling_fraction, tol, maxiter, optimmethod, num_cycles = 1) #> Warning: Warning: you set some transitions as impossible to happen. #> Calculating the likelihood for the initial parameters. #> 0.0565371031208431 0.0565371031208431 4 -138.298934331982 #> Calculating the likelihood for the initial parameters. #> The loglikelihood for the initial parameter values is -138.298934331982 #> Optimizing the likelihood - this may take a while. #> 0.0565371031208431 0.0565371031208431 4 -138.298934331982 #> -19.6874997974797 0.0565371031208431 4 -Inf #> 0.0565371031208431 -19.6874997974797 4 -Inf #> 0.0565371031208431 0.0565371031208431 -2.25 -Inf #> 2.57370518668921 2.57370518668921 -0.166666666666667 -Inf #> 1.23970037744085 1.23970037744085 0.428571428571429 -691.958779659467 #> -19.6874997974797 -0.380096751677633 0.875 -Inf #> 4.08936171714845 -0.164220824193095 1.22222222222222 -Inf #> 1.23970037744085 0.0565371031208431 4 -440.773537485506 #> 0.0565371031208431 1.23970037744085 4 -429.583737252523 #> 0.435774310919359 0.435774310919359 1.22222222222222 -318.571940853746 #> -0.218641114628526 1.23970037744085 1.72727272727273 -Inf #> 0.52713343399769 0.217302799841525 3.13793103448276 -285.902642345955 #> 0.708300271490812 -0.164220824193095 1.53521126760563 -Inf #> 0.167937068470423 0.577316190034945 3.02234636871508 -282.871768123795 #> 0.0617304252867121 0.105190205544315 97.1818181818192 -144.357859809279 #> -0.148851675061786 0.197064057770502 14.5769230769231 -Inf #> 0.27414982297335 0.212179226347973 4.06843957763004 -216.665398325022 #> 0.0800160544267704 -0.130579936021718 42.3928571428568 -Inf #> 0.144641570413977 0.310548624807354 4.20238174884592 -208.106952257705 #> -0.164220824193095 0.0565371031208431 4 -Inf #> 0.0565371031208431 -0.164220824193095 4 -Inf #> 0.0565371031208431 0.0565371031208431 1.22222222222222 -140.359131653645 #> -0.101652478250067 0.435774310919359 1.72727272727273 -Inf #> -0.0667186885311693 0.217302799841525 2.07692307692308 -Inf #> -0.0667186885311693 0.0565371031208431 4 -Inf #> 0.0565371031208431 -0.0667186885311693 4 -Inf #> 0.0565371031208431 0.0565371031208431 2.07692307692308 -139.142157929906 #> -0.0289580508740217 0.217302799841525 2.52941176470588 -Inf #> -0.00890822400049493 0.13123669972533 2.80952380952381 -Inf #> -0.00890822400049493 0.0565371031208431 4 -Inf #> 0.0565371031208431 -0.00890822400049493 4 -Inf #> 0.0565371031208431 0.0565371031208431 2.80952380952381 -138.679216775811 #> 0.13123669972533 0.0565371031208431 4 -147.961635290365 #> 0.0565371031208431 0.13123669972533 4 -148.308000572893 #> 0.0565371031208431 0.0565371031208431 6.27272727272728 -138.007338966656 #> 0.105190205544315 -0.00890822400049493 5.31578947368422 -Inf #> 0.0682943175325757 0.0926116256780313 4.27472527472528 -143.832962010837 #> -0.00203968049049697 0.0803161467061682 5.60550458715597 -Inf #> 0.0946881343274375 0.0623831825484161 4.32347504621072 -143.090397608342 #> 0.0696168471619277 0.0264136556123879 5.22478386167147 -136.921885084989 #> 0.0702793406885307 -0.00376572610556988 5.84085510688836 -Inf #> 0.0290624149289556 0.0306992264027016 5.93233484889008 -138.621352857041 #> 0.0447199562294352 0.0384417109814988 5.44535621036927 -136.933307966673 #> 0.0571834882945641 0.0245878726542851 8.78482446206113 -136.628878636959 #> 0.0575069775640771 0.00932706313748703 17.7622149837132 -137.320515830327 #> 0.0576148513184024 0.00434065127435459 6.08390270565726 -137.660673707848 #> 0.0573452081868561 0.01690021567186 6.13018361873322 -136.854754461495 #> 0.0785180903673741 0.00726785049012128 7.80434782608691 -136.666937697963 #> 0.0589471061052005 0.00619256503065626 12.0371363903092 -137.452234818503 #> 0.0669293051341006 0.0212825683726463 6.16013858035703 -136.672643062392 #> 0.0777955629677048 0.0184151658513158 9.33996720003544 -136.875724554663 #> 0.0623846944917256 0.0172785305143808 6.73008650701768 -136.669345797232 #> 0.0649759220488105 0.0114221191842328 10.0578020753919 -136.754395810525 #> 0.0664402878763672 0.0187994754408668 6.85206414499345 -136.629425789172 #> 0.0722796266989215 0.0163897753025553 9.06121371968436 -136.664270250248 #> 0.0523333066096938 0.0328819777396786 8.45922624799519 -136.644993775985 #> 0.0571834882945641 0.0245878726542851 10.5508021390374 -136.613308154471 #> 0.0571834882945641 0.00844351337212945 8.78482446206113 -137.355384151119 #> 0.0749398740088071 0.0245878726542851 8.78482446206113 -137.000906937715 #> 0.068955173283337 0.0412575580652741 9.89533417402267 -137.624616470001 #> 0.060102036129208 0.0164515916081767 9.04067402672863 -136.731122956905 #> 0.0418853769445456 0.0191492893092306 10.1053984575835 -137.888333508846 #> 0.0664811703227776 0.0232227923625168 9.08462211847093 -136.66198726639 #> 0.0604273142411855 0.0319302561674392 9.82706766917288 -136.710730397943 #> 0.0603459760007705 0.0280165617887137 9.61914272545702 -136.632078981995 #> 0.0501164607402297 0.0282459571605786 10.1772315653298 -136.685283618422 #> 0.0623423617057083 0.0244739768629935 9.33724669109395 -136.618114250976 #> 0.0574530489386094 0.0211065491733346 9.39815464848055 -136.674823358777 #> 0.0596212613135387 0.0262803056984378 9.56301975217448 -136.609555054174 #> 0.0622516599521428 0.0256394398772377 11.0305172263747 -136.618678970996 #> 0.0609800668078614 0.0253763457627227 10.3776997414283 -136.606990168284 #> 0.0561940323902956 0.0263565014061938 11.0939591443943 -136.602172403796 #> 0.0531464784189513 0.0273003604917051 12.2170088677485 -136.620110696617 #> 0.0561940323902956 0.0263565014061938 11.6936320646434 -136.598644220989 #> 0.0561940323902956 0.0304879388893961 11.0939591443943 -136.601806771684 #> 0.0518543360127933 0.0263565014061938 11.0939591443943 -136.675223626732 #> 0.0605696861929951 0.0291071023570987 11.4872408653628 -136.638494002533 #> 0.0583773367400651 0.0284180708851324 11.3865418216029 -136.60113479112 #> 0.0576485663801091 0.0304879388893961 11.6936320646434 -136.611874413809 #> 0.0565572906928047 0.0273862519522353 11.2385020583417 -136.593948611902 #> 0.0578913782940932 0.0243031806466864 11.7994074348409 -136.603648335777 #> 0.056617858037715 0.0289347579451092 11.2629291226824 -136.594310348995 #> 0.0545423449410474 0.0266995221514903 11.4032120586783 -136.613596233567 #> 0.0574159761990854 0.0279878945637536 11.3907051784793 -136.593358794518 #> 0.0575339439395769 0.029854595782983 10.9244371603553 -136.609233101096 #> 0.0565286918602074 0.0272287952443322 11.4921777044809 -136.592915772936 #> 0.057049882100307 0.0261374692352738 11.4848913607935 -136.596052406048 #> 0.05672583094284 0.0282340069577987 11.3176764761025 -136.592659853417 # ML -136.5796"},{"path":"https://rsetienne.github.io/secsse/reference/create_default_lambda_list.html","id":null,"dir":"Reference","previous_headings":"","what":"helper function to create a default lambda list — create_default_lambda_list","title":"helper function to create a default lambda list — create_default_lambda_list","text":"function generates generic lambda list, assuming transitions states, e.g. species observed state 0 generates daughter species state 0 well.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/create_default_lambda_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"helper function to create a default lambda list — create_default_lambda_list","text":"","code":"create_default_lambda_list(state_names = c(\"0\", \"1\"), model = \"ETD\")"},{"path":"https://rsetienne.github.io/secsse/reference/create_default_lambda_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"helper function to create a default lambda list — create_default_lambda_list","text":"state_names names observed states model chosen model interest, either \"CR\" (Constant Rates), \"ETD\"  (Examined Trait Diversification) \"CTD\" (\"Concealed Trait Diversification).","code":""},{"path":"https://rsetienne.github.io/secsse/reference/create_default_q_list.html","id":null,"dir":"Reference","previous_headings":"","what":"helper function to create a default q_matrix list — create_default_q_list","title":"helper function to create a default q_matrix list — create_default_q_list","text":"function generates generic transition list","code":""},{"path":"https://rsetienne.github.io/secsse/reference/create_default_q_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"helper function to create a default q_matrix list — create_default_q_list","text":"","code":"create_default_q_list(   state_names = c(\"0\", \"1\"),   num_concealed_states,   mus = NULL )"},{"path":"https://rsetienne.github.io/secsse/reference/create_default_q_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"helper function to create a default q_matrix list — create_default_q_list","text":"state_names names observed states num_concealed_states number concealed states mus previously defined mus - used choose indicator number","code":""},{"path":"https://rsetienne.github.io/secsse/reference/create_lambda_matrices.html","id":null,"dir":"Reference","previous_headings":"","what":"helper function to automatically create lambda matrices, based on input — create_lambda_matrices","title":"helper function to automatically create lambda matrices, based on input — create_lambda_matrices","text":"helper function automatically create lambda matrices, based input","code":""},{"path":"https://rsetienne.github.io/secsse/reference/create_lambda_matrices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"helper function to automatically create lambda matrices, based on input — create_lambda_matrices","text":"","code":"create_lambda_matrices(   state_names,   num_concealed_states,   transition_list,   model = \"ETD\",   concealed_spec_rates = NULL )"},{"path":"https://rsetienne.github.io/secsse/reference/create_lambda_matrices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"helper function to automatically create lambda matrices, based on input — create_lambda_matrices","text":"state_names vector names observed states num_concealed_states number hidden states transition_list matrix containing description speciation events, first column indicates source state, second third column indicate two daughter states, fourth column gives rate indicator used. E.g.: [\"SA\", \"S\", \"\", 1] trait state \"SA\" upon speciation generates two daughter species traits \"S\" \"\", number 1 used indicator optimization likelihood. model used model, choice \"ETD\" (Examined Traits Diversification) \"CTD\" (Concealed Traits Diversification). concealed_spec_rates vector specifying rate indicators concealed state, length identical num_concealed_states. left empty using CTD model, assumed available speciation rates distributed uniformly concealed states.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/create_mus.html","id":null,"dir":"Reference","previous_headings":"","what":"function to generate generic mus vector — create_mus","title":"function to generate generic mus vector — create_mus","text":"function generate generic mus vector","code":""},{"path":"https://rsetienne.github.io/secsse/reference/create_mus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"function to generate generic mus vector — create_mus","text":"","code":"create_mus(state_names, num_concealed_states, model = \"CR\", lambdas)"},{"path":"https://rsetienne.github.io/secsse/reference/create_mus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"function to generate generic mus vector — create_mus","text":"state_names full state names, including concealed states, example c(\"0A\", \"1A\", \"0B\", \"1B\") num_concealed_states number concealed states model model replicated, available \"CR\", \"ETD\" \"CTD\" lambdas previously generated lambda matrices, used infer rate number start ","code":""},{"path":"https://rsetienne.github.io/secsse/reference/create_mus.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"function to generate generic mus vector — create_mus","text":"mu vector","code":""},{"path":"https://rsetienne.github.io/secsse/reference/create_transition_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"helper function to neatly setup a Q matrix, without transitions to\nconcealed states (only observed transitions shown) — create_transition_matrix","title":"helper function to neatly setup a Q matrix, without transitions to\nconcealed states (only observed transitions shown) — create_transition_matrix","text":"helper function neatly setup Q matrix, without transitions concealed states (observed transitions shown)","code":""},{"path":"https://rsetienne.github.io/secsse/reference/create_transition_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"helper function to neatly setup a Q matrix, without transitions to\nconcealed states (only observed transitions shown) — create_transition_matrix","text":"","code":"create_transition_matrix(   state_names,   num_concealed_states,   transition_list,   diff.conceal = FALSE )"},{"path":"https://rsetienne.github.io/secsse/reference/create_transition_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"helper function to neatly setup a Q matrix, without transitions to\nconcealed states (only observed transitions shown) — create_transition_matrix","text":"state_names names observed states num_concealed_states number concealed states transition_list matrix transitions, indicating order: 1) starting state (typically column transition matrix), 2) ending state (typically row transition matrix) 3) associated rate indicator diff.conceal use number rates concealed state transitions, concealed state transitions separate rates? Typically, FALSE fine used order avoid huge number parameters.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/create_transition_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"helper function to neatly setup a Q matrix, without transitions to\nconcealed states (only observed transitions shown) — create_transition_matrix","text":"transition matrix","code":""},{"path":"https://rsetienne.github.io/secsse/reference/event_times.html","id":null,"dir":"Reference","previous_headings":"","what":"Event times of a (possibly non-ultrametric) phylogenetic tree — event_times","title":"Event times of a (possibly non-ultrametric) phylogenetic tree — event_times","text":"Times speciation extinction occurs","code":""},{"path":"https://rsetienne.github.io/secsse/reference/event_times.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Event times of a (possibly non-ultrametric) phylogenetic tree — event_times","text":"","code":"event_times(phy)"},{"path":"https://rsetienne.github.io/secsse/reference/event_times.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Event times of a (possibly non-ultrametric) phylogenetic tree — event_times","text":"phy phylogenetic tree class phylo, without polytomies, rooted branch lengths. Need ultrametric.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/event_times.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Event times of a (possibly non-ultrametric) phylogenetic tree — event_times","text":"times speciation extinction happens.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/event_times.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Event times of a (possibly non-ultrametric) phylogenetic tree — event_times","text":"script modified BAMMtools' internal function NU.branching.times","code":""},{"path":"https://rsetienne.github.io/secsse/reference/example_phy_GeoSSE.html","id":null,"dir":"Reference","previous_headings":"","what":"A phylogeny with traits at the tips — example_phy_GeoSSE","title":"A phylogeny with traits at the tips — example_phy_GeoSSE","text":"example phylogeny testing purposes","code":""},{"path":"https://rsetienne.github.io/secsse/reference/example_phy_GeoSSE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A phylogeny with traits at the tips — example_phy_GeoSSE","text":"","code":"phy"},{"path":"https://rsetienne.github.io/secsse/reference/example_phy_GeoSSE.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A phylogeny with traits at the tips — example_phy_GeoSSE","text":"phylogeny created GeoSSE (diversitree)","code":""},{"path":"https://rsetienne.github.io/secsse/reference/expand_q_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"function to expand an existing q_matrix to a number of\nconcealed states — expand_q_matrix","title":"function to expand an existing q_matrix to a number of\nconcealed states — expand_q_matrix","text":"function expand existing q_matrix number concealed states","code":""},{"path":"https://rsetienne.github.io/secsse/reference/expand_q_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"function to expand an existing q_matrix to a number of\nconcealed states — expand_q_matrix","text":"","code":"expand_q_matrix(q_matrix, num_concealed_states, diff.conceal = FALSE)"},{"path":"https://rsetienne.github.io/secsse/reference/expand_q_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"function to expand an existing q_matrix to a number of\nconcealed states — expand_q_matrix","text":"q_matrix q_matrix transitions observed states num_concealed_states number concealed states diff.conceal use number rates concealed state transitions, concealed state transitions separate rates? Typically, FALSE fine used order avoid huge number parameters.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/expand_q_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"function to expand an existing q_matrix to a number of\nconcealed states — expand_q_matrix","text":"updated q matrix","code":""},{"path":"https://rsetienne.github.io/secsse/reference/extract_par_vals.html","id":null,"dir":"Reference","previous_headings":"","what":"function to extract parameter values out of the result of a maximum\nlikelihood inference run. — extract_par_vals","title":"function to extract parameter values out of the result of a maximum\nlikelihood inference run. — extract_par_vals","text":"function extract parameter values result maximum likelihood inference run.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/extract_par_vals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"function to extract parameter values out of the result of a maximum\nlikelihood inference run. — extract_par_vals","text":"","code":"extract_par_vals(param_posit, ml_pars)"},{"path":"https://rsetienne.github.io/secsse/reference/extract_par_vals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"function to extract parameter values out of the result of a maximum\nlikelihood inference run. — extract_par_vals","text":"param_posit initial parameter structure, consisting list three entries: 1) lambda matrices, 2) mus 3) Q matrix. entry, integers numbers (1-n) indicate parameter optimized ml_pars resulting parameter estimates returned instance cla_secsse_ml, structure param_post","code":""},{"path":"https://rsetienne.github.io/secsse/reference/extract_par_vals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"function to extract parameter values out of the result of a maximum\nlikelihood inference run. — extract_par_vals","text":"vector parameter estimates","code":""},{"path":"https://rsetienne.github.io/secsse/reference/fill_in.html","id":null,"dir":"Reference","previous_headings":"","what":"helper function to enter parameter value on their right place — fill_in","title":"helper function to enter parameter value on their right place — fill_in","text":"helper function enter parameter value right place","code":""},{"path":"https://rsetienne.github.io/secsse/reference/fill_in.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"helper function to enter parameter value on their right place — fill_in","text":"","code":"fill_in(object, params)"},{"path":"https://rsetienne.github.io/secsse/reference/fill_in.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"helper function to enter parameter value on their right place — fill_in","text":"object lambda matrices, q_matrix mu vector params parameters order, value reflects value parameter position, e.g. c(0.3, 0.2, 0.1) fill value 0.3 parameter rate indentifier 1, 0.2 parameter rate identifier 2 0.1 parameter rate identifier 3","code":""},{"path":"https://rsetienne.github.io/secsse/reference/id_paramPos.html","id":null,"dir":"Reference","previous_headings":"","what":"Parameter structure setting — id_paramPos","title":"Parameter structure setting — id_paramPos","text":"sets parameters (speciation, extinction transition) ids. Needed ML calculation (secsse_ml)","code":""},{"path":"https://rsetienne.github.io/secsse/reference/id_paramPos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parameter structure setting — id_paramPos","text":"","code":"id_paramPos(traits, num_concealed_states)"},{"path":"https://rsetienne.github.io/secsse/reference/id_paramPos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parameter structure setting — id_paramPos","text":"traits vector trait states, order states must tree tips, help, see vignette. num_concealed_states number concealed states, generally equivalent number examined states.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/id_paramPos.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parameter structure setting — id_paramPos","text":"list includes ids parameters ML analysis.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/id_paramPos.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parameter structure setting — id_paramPos","text":"","code":"traits <- sample(c(0,1,2), 45,replace = TRUE) #get some traits num_concealed_states <- 3 param_posit <- id_paramPos(traits,num_concealed_states)"},{"path":"https://rsetienne.github.io/secsse/reference/phylo_Vign.html","id":null,"dir":"Reference","previous_headings":"","what":"A phylogenetic reconstuction to run the vignette — phylo_Vign","title":"A phylogenetic reconstuction to run the vignette — phylo_Vign","text":"example phylogeny right format secsse","code":""},{"path":"https://rsetienne.github.io/secsse/reference/phylo_Vign.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A phylogenetic reconstuction to run the vignette — phylo_Vign","text":"Phylogenetic tree format nexus, rooted, including branch lengths","code":""},{"path":"https://rsetienne.github.io/secsse/reference/plot_state_exact.html","id":null,"dir":"Reference","previous_headings":"","what":"function to plot the local probability along the tree, including the branches — plot_state_exact","title":"function to plot the local probability along the tree, including the branches — plot_state_exact","text":"function evaluate log likelihood locally along branches plot result. steps left NULL, likelihood evaluations integration used plotting. may work large trees, may become memory heavy larger trees. Instead, user can indicate number steps, causes probabilities evaluated distinct amount steps along branch (probabilities properly integrated steps). provides approximation, generally results look similar using full evaluation. function used prob_func highly dependent system. instance, 3 observed, 2 hidden states model, probability state prob[1] + prob[2] + prob[3], normalized row sum. prob_func applied row 'states' matrix (can thus test function states matrix returned 'see_ancestral_states = TRUE'). Please note first N columns states matrix extinction rates, (N+1):2N columns belong speciation rates, N = num_obs_states * num_concealed_states.  typical probfunc function look like: my_prob_func <- function(x)   return(sum(x[5:8]) / sum(x))","code":""},{"path":"https://rsetienne.github.io/secsse/reference/plot_state_exact.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"function to plot the local probability along the tree, including the branches — plot_state_exact","text":"","code":"plot_state_exact(   parameters,   focal_tree,   traits,   num_concealed_states,   sampling_fraction,   cond = \"proper_cond\",   root_state_weight = \"proper_weights\",   is_complete_tree = FALSE,   method = \"odeint::bulirsch_stoer\",   atol = 1e-16,   rtol = 1e-16,   steps = NULL,   prob_func = NULL,   verbose = FALSE )"},{"path":"https://rsetienne.github.io/secsse/reference/plot_state_exact.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"function to plot the local probability along the tree, including the branches — plot_state_exact","text":"parameters used parameters likelihood calculation focal_tree used phylogeny traits used traits num_concealed_states number concealed states sampling_fraction sampling fraction cond condition existence node root: 'maddison_cond', 'proper_cond'(default). details, see vignette. root_state_weight method weigh states:'maddison_weigh ,'proper_weights'(default) 'equal_weights'. can also specified root state:vector c(1,0,0) indicates state 1 root state. is_complete_tree whether tree extinct species provided method integration method used, available : \"odeint::runge_kutta_cash_karp54\", \"odeint::runge_kutta_fehlberg78\", \"odeint::runge_kutta_dopri5\", \"odeint::bulirsch_stoer\" \"odeint::runge_kutta4\". Default method :\"odeint::bulirsch_stoer\". atol absolute tolerance integration rtol relative tolerance integration steps number substeps evaluated per branch, see description. prob_func function calculate probability interest, see description verbose provides intermediate output (progressbars etc) TRUE.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/plot_state_exact.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"function to plot the local probability along the tree, including the branches — plot_state_exact","text":"ggplot2 object","code":""},{"path":"https://rsetienne.github.io/secsse/reference/plot_state_exact.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"function to plot the local probability along the tree, including the branches — plot_state_exact","text":"","code":"set.seed(5) focal_tree <- ape::rphylo(n = 4, birth = 1, death = 0) traits <- c(0, 1, 1, 0) params <- secsse::id_paramPos(c(0, 1), 2) params[[1]][] <- c(0.2, 0.2, 0.1, 0.1) params[[2]][] <- 0.0 params[[3]][, ] <- 0.1 diag(params[[3]]) <- NA #  Thus, we have for both, rates # 0A, 1A, 0B and 1B. If we are interested in the posterior probability of # trait 0,we have to provide a helper function that sums the probabilities of # 0A and 0B, e.g.: helper_function <- function(x) {   return(sum(x[c(5, 7)]) / sum(x)) # normalized by total sum, just in case. }  out_plot <- plot_state_exact(parameters = params,                              focal_tree = focal_tree,                              traits = traits,                              num_concealed_states = 2,                              sampling_fraction = c(1, 1),                              steps = 10,                              prob_func = helper_function)"},{"path":"https://rsetienne.github.io/secsse/reference/plot_state_exact_cla.html","id":null,"dir":"Reference","previous_headings":"","what":"function to plot the local probability along the tree,\nincluding the branches, for the CLA model. — plot_state_exact_cla","title":"function to plot the local probability along the tree,\nincluding the branches, for the CLA model. — plot_state_exact_cla","text":"function evaluate log likelihood locally along branches plot result. steps left NULL, likelihood evaluations integration used plotting. may work large trees, may become memory heavy larger trees. Instead, user can indicate number steps, causes probabilities evaluated distinct amount steps along branch (probabilities properly integrated steps). provides approximation, generally results look similar using full evaluation. function used prob_func highly dependent system. instance, 3 observed, 2 hidden states model, probability state prob[1] + prob[2] + prob[3], normalized row sum. prob_func applied row 'states' matrix (can thus test function states matrix returned 'see_ancestral_states = TRUE'). Please note first N columns states matrix extinction rates, (N+1):2N columns belong speciation rates, N = num_obs_states * num_concealed_states. typical probfunc function look like: my_prob_func <- function(x)   return(sum(x[5:8]) / sum(x))","code":""},{"path":"https://rsetienne.github.io/secsse/reference/plot_state_exact_cla.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"function to plot the local probability along the tree,\nincluding the branches, for the CLA model. — plot_state_exact_cla","text":"","code":"plot_state_exact_cla(   parameters,   focal_tree,   traits,   num_concealed_states,   sampling_fraction,   cond = \"proper_cond\",   root_state_weight = \"proper_weights\",   is_complete_tree = FALSE,   method = \"odeint::bulirsch_stoer\",   atol = 1e-16,   rtol = 1e-16,   steps = 10,   prob_func = NULL,   verbose = FALSE )"},{"path":"https://rsetienne.github.io/secsse/reference/plot_state_exact_cla.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"function to plot the local probability along the tree,\nincluding the branches, for the CLA model. — plot_state_exact_cla","text":"parameters used parameters likelihood calculation focal_tree used phylogeny traits used traits num_concealed_states number concealed states sampling_fraction sampling fraction cond condition existence node root: 'maddison_cond', 'proper_cond'(default). details, see vignette. root_state_weight method weigh states:'maddison_weigh ,'proper_weights'(default) 'equal_weights'. can also specified root state:vector c(1,0,0) indicates state 1 root state. is_complete_tree whether tree extinct species provided method integration method used, available : \"odeint::runge_kutta_cash_karp54\", \"odeint::runge_kutta_fehlberg78\", \"odeint::runge_kutta_dopri5\", \"odeint::bulirsch_stoer\" \"odeint::runge_kutta4\". Default method :\"odeint::bulirsch_stoer\". atol absolute tolerance integration rtol relative tolerance integration steps number substeps evaluated per branch, see description. prob_func function calculate probability interest, see description verbose return verbose output / progress bars true.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/plot_state_exact_cla.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"function to plot the local probability along the tree,\nincluding the branches, for the CLA model. — plot_state_exact_cla","text":"ggplot2 object","code":""},{"path":"https://rsetienne.github.io/secsse/reference/plot_state_exact_cla.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"function to plot the local probability along the tree,\nincluding the branches, for the CLA model. — plot_state_exact_cla","text":"","code":"set.seed(13) phylotree <- ape::rcoal(12, tip.label = 1:12) traits <- sample(c(0, 1, 2), ape::Ntip(phylotree), replace = TRUE) num_concealed_states <- 3 sampling_fraction <- c(1,1,1) phy <- phylotree # the idparlist for a ETD model (dual state inheritance model of evolution) # would be set like this: idparlist <- secsse::cla_id_paramPos(traits,num_concealed_states) lambd_and_modeSpe <- idparlist$lambdas lambd_and_modeSpe[1,] <- c(1,1,1,2,2,2,3,3,3) idparlist[[1]] <- lambd_and_modeSpe idparlist[[2]][] <- 0 masterBlock <- matrix(4,ncol = 3, nrow = 3, byrow = TRUE) diag(masterBlock) <- NA idparlist[[3]] <- q_doubletrans(traits, masterBlock, diff.conceal = FALSE) # Now, internally, clasecsse sorts the lambda matrices, so they look like #  a list with 9 matrices, corresponding to the 9 states # (0A,1A,2A,0B, etc) parameter <- idparlist lambda_and_modeSpe <- parameter$lambdas lambda_and_modeSpe[1,] <- c(0.2,0.2,0.2,0.4,0.4,0.4,0.01,0.01,0.01) parameter[[1]] <- prepare_full_lambdas(traits,num_concealed_states,                                       lambda_and_modeSpe) parameter[[2]] <- rep(0,9) masterBlock <- matrix(0.07, ncol = 3, nrow = 3, byrow = TRUE) diag(masterBlock) <- NA parameter[[3]] <- q_doubletrans(traits, masterBlock, diff.conceal = FALSE) helper_function <- function(x) {  return(sum(x[c(10, 13, 16)]) / sum(x)) } out_plot <- plot_state_exact_cla(parameters = parameter,                                 focal_tree = phy,                                 traits = traits,                                 num_concealed_states = 3,                                 sampling_fraction = sampling_fraction,                                 cond = 'maddison_cond',                                 root_state_weight = 'maddison_weights',                                 is_complete_tree = FALSE,                                 prob_func = helper_function,                                 steps = 10)"},{"path":"https://rsetienne.github.io/secsse/reference/prepare_full_lambdas.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepares the entire set of lambda matrices for cla_secsse. — prepare_full_lambdas","title":"Prepares the entire set of lambda matrices for cla_secsse. — prepare_full_lambdas","text":"provides set matrices containing speciation rates","code":""},{"path":"https://rsetienne.github.io/secsse/reference/prepare_full_lambdas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepares the entire set of lambda matrices for cla_secsse. — prepare_full_lambdas","text":"","code":"prepare_full_lambdas(traits, num_concealed_states, lambd_and_modeSpe)"},{"path":"https://rsetienne.github.io/secsse/reference/prepare_full_lambdas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepares the entire set of lambda matrices for cla_secsse. — prepare_full_lambdas","text":"traits vector trait states, order states must tree tips, help, see vignette. num_concealed_states number concealed states, generally equivalent number examined states. lambd_and_modeSpe matrix 4 models speciation possible.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/prepare_full_lambdas.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepares the entire set of lambda matrices for cla_secsse. — prepare_full_lambdas","text":"list lambdas, length number trait states * num_concealed_states..","code":""},{"path":"https://rsetienne.github.io/secsse/reference/prepare_full_lambdas.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepares the entire set of lambda matrices for cla_secsse. — prepare_full_lambdas","text":"","code":"set.seed(13) phylotree <- ape::rcoal(12, tip.label = 1:12) traits <- sample(c(0, 1, 2),                  ape::Ntip(phylotree), replace = TRUE) num_concealed_states <- 3 # the idparlist for a ETD model (dual state inheritance model of evolution) # would be set like this: idparlist <- secsse::cla_id_paramPos(traits, num_concealed_states) lambd_and_modeSpe <- idparlist$lambdas lambd_and_modeSpe[1, ] <- c(1, 1, 1, 2, 2, 2, 3, 3, 3) idparlist[[1]] <- lambd_and_modeSpe idparlist[[2]][] <- 0 masterBlock <- matrix(4, ncol = 3, nrow = 3, byrow = TRUE) diag(masterBlock) <- NA idparlist[[3]] <- q_doubletrans(traits, masterBlock, diff.conceal = FALSE) # Now, internally, clasecsse sorts the lambda matrices, so they look like #  a list with 9 matrices, corresponding to the 9 states # (0A,1A,2A,0B, etc)  parameter <- idparlist lambda_and_modeSpe <- parameter$lambdas lambda_and_modeSpe[1, ] <- c(0.2, 0.2, 0.2, 0.4, 0.4, 0.4, 0.01, 0.01, 0.01) parameter[[1]] <- prepare_full_lambdas(traits, num_concealed_states,                                        lambda_and_modeSpe)"},{"path":"https://rsetienne.github.io/secsse/reference/q_doubletrans.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic Qmatrix — q_doubletrans","title":"Basic Qmatrix — q_doubletrans","text":"function expands Q_matrix, assuming number concealed traits equal number examined  traits, different number, consider looking function [expand_q_matrix()].","code":""},{"path":"https://rsetienne.github.io/secsse/reference/q_doubletrans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic Qmatrix — q_doubletrans","text":"","code":"q_doubletrans(traits, masterBlock, diff.conceal)"},{"path":"https://rsetienne.github.io/secsse/reference/q_doubletrans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic Qmatrix — q_doubletrans","text":"traits vector trait states, order states must tree tips, help, see vignette. masterBlock matrix transitions among examined states, NA main diagonal, used build full transition rates matrix. diff.conceal concealed states different? Normally FALSE. E.g. transition rates concealed states different transition rates examined states.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/q_doubletrans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic Qmatrix — q_doubletrans","text":"Q matrix includes examined concealed states, declared third element idparslist.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/q_doubletrans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Basic Qmatrix — q_doubletrans","text":"Sets Q matrix double transitions allowed","code":""},{"path":"https://rsetienne.github.io/secsse/reference/q_doubletrans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Basic Qmatrix — q_doubletrans","text":"","code":"traits <- sample(c(0,1,2), 45,replace = TRUE) #get some traits # For a three-state trait masterBlock <- matrix(99,ncol = 3,nrow = 3,byrow = TRUE) diag(masterBlock) <- NA masterBlock[1,2] <- 6 masterBlock[1,3] <- 7 masterBlock[2,1] <- 8 masterBlock[2,3] <- 9 masterBlock[3,1] <- 10 masterBlock[3,2] <- 11 myQ <- q_doubletrans(traits,masterBlock,diff.conceal = FALSE) # now, it can replace the Q matrix from id_paramPos num_concealed_states <- 3 param_posit <- id_paramPos(traits,num_concealed_states) param_posit[[3]] <- myQ"},{"path":"https://rsetienne.github.io/secsse/reference/secsse-package.html","id":null,"dir":"Reference","previous_headings":"","what":"secsse: Several Examined and Concealed States-Dependent Speciation and Extinction — secsse-package","title":"secsse: Several Examined and Concealed States-Dependent Speciation and Extinction — secsse-package","text":"Simultaneously infers state-dependent diversification across two states single multiple traits accounting role possible concealed trait. See Herrera-Alsina et al. (2019) doi:10.1093/sysbio/syy057 .","code":""},{"path":[]},{"path":"https://rsetienne.github.io/secsse/reference/secsse-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"secsse: Several Examined and Concealed States-Dependent Speciation and Extinction — secsse-package","text":"Maintainer: Rampal S. Etienne r.s.etienne@rug.nl (ORCID) Authors: Leonel Herrera Alsina leonelhalsina@gmail.com (ORCID) Paul van Els paulvanels@gmail.com (ORCID) contributors: Thijs Janzen t.janzen@rug.nl (ORCID) [contributor] Hanno Hildenbrandt h.hildenbrandt@rug.nl (ORCID) [contributor] Pedro Santos Neves p.m.santos.neves@rug.nl (ORCID) [contributor]","code":""},{"path":"https://rsetienne.github.io/secsse/reference/secsse_loglik.html","id":null,"dir":"Reference","previous_headings":"","what":"Likelihood for SecSSE model — secsse_loglik","title":"Likelihood for SecSSE model — secsse_loglik","text":"Logikelihood calculation SecSSE model given set parameters data","code":""},{"path":"https://rsetienne.github.io/secsse/reference/secsse_loglik.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Likelihood for SecSSE model — secsse_loglik","text":"","code":"secsse_loglik(   parameter,   phy,   traits,   num_concealed_states,   cond = \"proper_cond\",   root_state_weight = \"proper_weights\",   sampling_fraction,   setting_calculation = NULL,   see_ancestral_states = FALSE,   loglik_penalty = 0,   is_complete_tree = FALSE,   num_threads = 1,   atol = 1e-08,   rtol = 1e-07,   method = \"odeint::bulirsch_stoer\" )"},{"path":"https://rsetienne.github.io/secsse/reference/secsse_loglik.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Likelihood for SecSSE model — secsse_loglik","text":"parameter list first vector represents lambdas, second mus third transition rates. phy phylogenetic tree class phylo, ultrametric, fully-resolved, rooted branch lengths. traits vector trait states, order states must tree tips, help, see vignette. num_concealed_states number concealed states, generally equivalent number examined states. cond condition existence node root: \"maddison_cond\", \"proper_cond\"(default). details, see vignette. root_state_weight method weigh states: \"maddison_weights\",\"proper_weights\"(default) \"equal_weights\". can also specified root state:vector c(1, 0, 0) indicates state 1 root state. sampling_fraction vector states sampling proportion per trait state. must many elements trait states. setting_calculation argument used internally speed calculation. left blank (default : setting_calculation = NULL) see_ancestral_states ancestral states shown? Default FALSE loglik_penalty size penalty parameters; default 0 (penalty) is_complete_tree whether tree extinct species provided num_threads number threads. Set -1 use available threads. Default one thread. atol absolute tolerance integration rtol relative tolerance integration method integration method used, available : \"odeint::runge_kutta_cash_karp54\", \"odeint::runge_kutta_fehlberg78\", \"odeint::runge_kutta_dopri5\", \"odeint::bulirsch_stoer\" \"odeint::runge_kutta4\". Default method :\"odeint::bulirsch_stoer\".","code":""},{"path":"https://rsetienne.github.io/secsse/reference/secsse_loglik.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Likelihood for SecSSE model — secsse_loglik","text":"loglikelihood data given parameter.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/secsse_loglik.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Likelihood for SecSSE model — secsse_loglik","text":"Multithreading might lead slightly reduced accuracy (order 1e-10) therefore enabled default. Please use discretion.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/secsse_loglik.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Likelihood for SecSSE model — secsse_loglik","text":"","code":"rm(list = ls(all = TRUE)) library(secsse) set.seed(13) phylotree <- ape::rcoal(31, tip.label = 1:31) traits <- sample(c(0,1,2),ape::Ntip(phylotree),replace = TRUE) num_concealed_states <- 2 cond <- \"proper_cond\" root_state_weight <- \"proper_weights\" sampling_fraction <- c(1,1,1) drill <- id_paramPos(traits,num_concealed_states) drill[[1]][] <- c(0.12,0.01,0.2,0.21,0.31,0.23) drill[[2]][] <- 0 drill[[3]][,] <- 0.1 diag(drill[[3]]) <- NA secsse_loglik(parameter = drill, phylotree, traits, num_concealed_states, cond, root_state_weight, sampling_fraction, see_ancestral_states = FALSE) #> [1] -113.0919  #[1] -113.1018"},{"path":"https://rsetienne.github.io/secsse/reference/secsse_loglik_eval.html","id":null,"dir":"Reference","previous_headings":"","what":"Likelihood for SecSSE model — secsse_loglik_eval","title":"Likelihood for SecSSE model — secsse_loglik_eval","text":"Logikelihood calculation SecSSE model given set parameters data, returning also likelihoods along branches","code":""},{"path":"https://rsetienne.github.io/secsse/reference/secsse_loglik_eval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Likelihood for SecSSE model — secsse_loglik_eval","text":"","code":"secsse_loglik_eval(   parameter,   phy,   traits,   num_concealed_states,   ancestral_states,   cond = \"proper_cond\",   root_state_weight = \"proper_weights\",   sampling_fraction,   setting_calculation = NULL,   loglik_penalty = 0,   is_complete_tree = FALSE,   atol = 1e-12,   rtol = 1e-12,   method = \"odeint::bulirsch_stoer\",   num_steps = NULL,   verbose = FALSE )"},{"path":"https://rsetienne.github.io/secsse/reference/secsse_loglik_eval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Likelihood for SecSSE model — secsse_loglik_eval","text":"parameter list first vector represents lambdas, second mus third transition rates. phy phylogenetic tree class phylo, ultrametric, fully-resolved, rooted branch lengths. traits vector trait states, order states must tree tips, help, see vignette. num_concealed_states number concealed states, generally equivalent number examined states. ancestral_states ancestral states matrix provided secsse_loglik, used starting points branch integration cond condition existence node root: \"maddison_cond\", \"proper_cond\"(default). details, see vignette. root_state_weight method weigh states:\"maddison_weights\", \"proper_weights\"(default) \"equal_weights\". can also specified root state:vector c(1,0,0) indicates state 1 root state. sampling_fraction vector states sampling proportion per trait state. must many elements trait states. setting_calculation argument used internally speed calculation. left blank (default : setting_calculation = NULL) loglik_penalty size penalty parameters; default 0 (penalty) is_complete_tree whether tree extinct species provided atol absolute tolerance integration rtol relative tolerance integration method integration method used, available : \"odeint::runge_kutta_cash_karp54\", \"odeint::runge_kutta_fehlberg78\", \"odeint::runge_kutta_dopri5\", \"odeint::bulirsch_stoer\" \"odeint::runge_kutta4\". Default method :\"odeint::bulirsch_stoer\". num_steps number substeps show intermediate likelihoods along branch, left NULL, intermediate likelihoods every integration evaluation stored, exact, can lead huge datasets / memory usage. verbose provides intermediate output TRUE","code":""},{"path":"https://rsetienne.github.io/secsse/reference/secsse_loglik_eval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Likelihood for SecSSE model — secsse_loglik_eval","text":"loglikelihood data given parameters","code":""},{"path":"https://rsetienne.github.io/secsse/reference/secsse_loglik_eval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Likelihood for SecSSE model — secsse_loglik_eval","text":"","code":"#' set.seed(5) focal_tree <- ape::rphylo(n = 4, birth = 1, death = 0) traits <- c(0, 1, 1, 0) params <- secsse::id_paramPos(c(0, 1), 2) params[[1]][] <- c(0.2, 0.2, 0.1, 0.1) params[[2]][] <- 0.0 params[[3]][, ] <- 0.1 diag(params[[3]]) <- NA #  Thus, we have for both, rates # 0A, 1A, 0B and 1B. If we are interested in the posterior probability of # trait 0 we have to provide a helper function that sums the probabilities of # 0A and 0B, e.g.: helper_function <- function(x) {   return(sum(x[c(5, 7)]) / sum(x)) # normalized by total sum, just in case. } ll <- secsse::secsse_loglik(parameter = params,                             phy = focal_tree,                             traits = traits,                             num_concealed_states = 2,                             sampling_fraction = c(1, 1),                             see_ancestral_states = TRUE)  secsse_loglik_eval(parameter = params,                    phy = focal_tree,                    traits = traits,                    ancestral_states = ll$states,                    num_concealed_states = 2,                    sampling_fraction = c(1, 1),                    num_steps = 10) #>       [,1] [,2]        [,3] [,4] [,5] [,6] [,7]        [,8]       [,9] #>  [1,]    7    2 0.000000000    0    0    0    0 0.000000000 1.00000000 #>  [2,]    7    2 0.061749385    0    0    0    0 0.012067596 0.97569590 #>  [3,]    7    2 0.123498770    0    0    0    0 0.023585127 0.95216464 #>  [4,]    7    2 0.185248155    0    0    0    0 0.034573732 0.92937924 #>  [5,]    7    2 0.246997541    0    0    0    0 0.045053766 0.90731368 #>  [6,]    7    2 0.308746926    0    0    0    0 0.055044830 0.88594290 #>  [7,]    7    2 0.370496311    0    0    0    0 0.064565797 0.86524270 #>  [8,]    7    2 0.432245696    0    0    0    0 0.073634839 0.84518976 #>  [9,]    7    2 0.493995081    0    0    0    0 0.082269453 0.82576162 #> [10,]    7    2 0.555744466    0    0    0    0 0.090486486 0.80693659 #> [11,]    7    2 0.617493852    0    0    0    0 0.098302161 0.78869376 #> [12,]    7    3 0.000000000    0    0    0    0 0.000000000 1.00000000 #> [13,]    7    3 0.061749385    0    0    0    0 0.012067596 0.97569590 #> [14,]    7    3 0.123498770    0    0    0    0 0.023585127 0.95216464 #> [15,]    7    3 0.185248155    0    0    0    0 0.034573732 0.92937924 #> [16,]    7    3 0.246997541    0    0    0    0 0.045053766 0.90731368 #> [17,]    7    3 0.308746926    0    0    0    0 0.055044830 0.88594290 #> [18,]    7    3 0.370496311    0    0    0    0 0.064565797 0.86524270 #> [19,]    7    3 0.432245696    0    0    0    0 0.073634839 0.84518976 #> [20,]    7    3 0.493995081    0    0    0    0 0.082269453 0.82576162 #> [21,]    7    3 0.555744466    0    0    0    0 0.090486486 0.80693659 #> [22,]    7    3 0.617493852    0    0    0    0 0.098302161 0.78869376 #> [23,]    6    7 0.000000000    0    0    0    0 0.009800922 0.63089575 #> [24,]    6    7 0.004461637    0    0    0    0 0.010220124 0.62965451 #> [25,]    6    7 0.008923273    0    0    0    0 0.010637879 0.62841627 #> [26,]    6    7 0.013384910    0    0    0    0 0.011054193 0.62718101 #> [27,]    6    7 0.017846547    0    0    0    0 0.011469068 0.62594873 #> [28,]    6    7 0.022308184    0    0    0    0 0.011882508 0.62471942 #> [29,]    6    7 0.026769820    0    0    0    0 0.012294519 0.62349307 #> [30,]    6    7 0.031231457    0    0    0    0 0.012705105 0.62226968 #> [31,]    6    7 0.035693094    0    0    0    0 0.013114268 0.62104923 #> [32,]    6    7 0.040154730    0    0    0    0 0.013522014 0.61983172 #> [33,]    6    7 0.044616367    0    0    0    0 0.013928347 0.61861715 #> [34,]    6    1 0.000000000    0    0    0    0 1.000000000 0.00000000 #> [35,]    6    1 0.066211022    0    0    0    0 0.973970104 0.01291796 #> [36,]    6    1 0.132422044    0    0    0    0 0.948826493 0.02520527 #> [37,]    6    1 0.198633066    0    0    0    0 0.924536041 0.03688789 #> [38,]    6    1 0.264844087    0    0    0    0 0.901066891 0.04799073 #> [39,]    6    1 0.331055109    0    0    0    0 0.878388409 0.05853774 #> [40,]    6    1 0.397266131    0    0    0    0 0.856471134 0.06855189 #> [41,]    6    1 0.463477153    0    0    0    0 0.835286733 0.07805526 #> [42,]    6    1 0.529688175    0    0    0    0 0.814807961 0.08706903 #> [43,]    6    1 0.595899197    0    0    0    0 0.795008614 0.09561355 #> [44,]    6    1 0.662110219    0    0    0    0 0.775863491 0.10370837 #> [45,]    5    6 0.000000000    0    0    0    0 0.110673162 0.65704211 #> [46,]    5    6 0.014955320    0    0    0    0 0.111171387 0.65265959 #> [47,]    5    6 0.029910641    0    0    0    0 0.111661239 0.64831230 #> [48,]    5    6 0.044865961    0    0    0    0 0.112142808 0.64399993 #> [49,]    5    6 0.059821282    0    0    0    0 0.112616183 0.63972220 #> [50,]    5    6 0.074776602    0    0    0    0 0.113081451 0.63547880 #> [51,]    5    6 0.089731923    0    0    0    0 0.113538698 0.63126944 #> [52,]    5    6 0.104687243    0    0    0    0 0.113988011 0.62709384 #> [53,]    5    6 0.119642564    0    0    0    0 0.114429474 0.62295170 #> [54,]    5    6 0.134597884    0    0    0    0 0.114863171 0.61884274 #> [55,]    5    6 0.149553205    0    0    0    0 0.115289185 0.61476668 #> [56,]    5    4 0.000000000    0    0    0    0 1.000000000 0.00000000 #> [57,]    5    4 0.081166342    0    0    0    0 0.968214545 0.01574753 #> [58,]    5    4 0.162332685    0    0    0    0 0.937749637 0.03055623 #> [59,]    5    4 0.243499027    0    0    0    0 0.908545047 0.04447325 #> [60,]    5    4 0.324665369    0    0    0    0 0.880543365 0.05754348 #> [61,]    5    4 0.405831712    0    0    0    0 0.853689868 0.06980963 #> [62,]    5    4 0.486998054    0    0    0    0 0.827932391 0.08131232 #> [63,]    5    4 0.568164396    0    0    0    0 0.803221208 0.09209022 #> [64,]    5    4 0.649330739    0    0    0    0 0.779508917 0.10218011 #> [65,]    5    4 0.730497081    0    0    0    0 0.756750331 0.11161699 #> [66,]    5    4 0.811663423    0    0    0    0 0.734902371 0.12043414 #>             [,10]      [,11] #>  [1,] 0.000000000 1.00000000 #>  [2,] 0.012104758 0.98170182 #>  [3,] 0.023730007 0.96384847 #>  [4,] 0.034891462 0.94642756 #>  [5,] 0.045604344 0.92942707 #>  [6,] 0.055883398 0.91283532 #>  [7,] 0.065742903 0.89664097 #>  [8,] 0.075196694 0.88083302 #>  [9,] 0.084258169 0.86540078 #> [10,] 0.092940304 0.85033389 #> [11,] 0.101255670 0.83562227 #> [12,] 0.000000000 1.00000000 #> [13,] 0.012104758 0.98170182 #> [14,] 0.023730007 0.96384847 #> [15,] 0.034891462 0.94642756 #> [16,] 0.045604344 0.92942707 #> [17,] 0.055883398 0.91283532 #> [18,] 0.065742903 0.89664097 #> [19,] 0.075196694 0.88083302 #> [20,] 0.084258169 0.86540078 #> [21,] 0.092940304 0.85033389 #> [22,] 0.101255670 0.83562227 #> [23,] 0.005199355 0.35410398 #> [24,] 0.005633273 0.35376042 #> [25,] 0.006065897 0.35341730 #> [26,] 0.006497232 0.35307462 #> [27,] 0.006927281 0.35273238 #> [28,] 0.007356046 0.35239058 #> [29,] 0.007783531 0.35204921 #> [30,] 0.008209739 0.35170828 #> [31,] 0.008634673 0.35136779 #> [32,] 0.009058336 0.35102773 #> [33,] 0.009480732 0.35068810 #> [34,] 1.000000000 0.00000000 #> [35,] 0.980397088 0.01296061 #> [36,] 0.961304571 0.02537123 #> [37,] 0.942707226 0.03725117 #> [38,] 0.924590305 0.04861909 #> [39,] 0.906939523 0.05949301 #> [40,] 0.889741037 0.06989037 #> [41,] 0.872981440 0.07982799 #> [42,] 0.856647741 0.08932216 #> [43,] 0.840727355 0.09838860 #> [44,] 0.825208089 0.10704250 #> [45,] 0.040062017 0.19222272 #> [46,] 0.041251549 0.19227869 #> [47,] 0.042428294 0.19233031 #> [48,] 0.043592364 0.19237765 #> [49,] 0.044743866 0.19242073 #> [50,] 0.045882908 0.19245962 #> [51,] 0.047009597 0.19249434 #> [52,] 0.048124040 0.19252496 #> [53,] 0.049226341 0.19255150 #> [54,] 0.050316606 0.19257403 #> [55,] 0.051394938 0.19259258 #> [56,] 1.000000000 0.00000000 #> [57,] 0.976040522 0.01581122 #> [58,] 0.952842848 0.03080254 #> [59,] 0.930379232 0.04500912 #> [60,] 0.908622988 0.05846467 #> [61,] 0.887548446 0.07120152 #> [62,] 0.867130917 0.08325068 #> [63,] 0.847346651 0.09464188 #> [64,] 0.828172805 0.10540363 #> [65,] 0.809587402 0.11556327 #> [66,] 0.791569305 0.12514700"},{"path":"https://rsetienne.github.io/secsse/reference/secsse_ml.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum likehood estimation for (SecSSE) — secsse_ml","title":"Maximum likehood estimation for (SecSSE) — secsse_ml","text":"Maximum likehood estimation Several examined concealed States-dependent Speciation Extinction (SecSSE)","code":""},{"path":"https://rsetienne.github.io/secsse/reference/secsse_ml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum likehood estimation for (SecSSE) — secsse_ml","text":"","code":"secsse_ml(   phy,   traits,   num_concealed_states,   idparslist,   idparsopt,   initparsopt,   idparsfix,   parsfix,   cond = \"proper_cond\",   root_state_weight = \"proper_weights\",   sampling_fraction,   tol = c(1e-04, 1e-05, 1e-07),   maxiter = 1000 * round((1.25)^length(idparsopt)),   optimmethod = \"subplex\",   num_cycles = 1,   loglik_penalty = 0,   is_complete_tree = FALSE,   verbose = (optimmethod == \"subplex\"),   num_threads = 1,   atol = 1e-08,   rtol = 1e-07,   method = \"odeint::bulirsch_stoer\" )"},{"path":"https://rsetienne.github.io/secsse/reference/secsse_ml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum likehood estimation for (SecSSE) — secsse_ml","text":"phy phylogenetic tree class phylo, ultrametric, rooted branch lengths. traits vector trait states tip phylogeny. num_concealed_states number concealed states, generally equivalent number examined states dataset. idparslist overview parameters values. idparsopt id parameters estimated. initparsopt initial guess parameters estimated. idparsfix id fixed parameters. parsfix value fixed parameters. cond condition existence node root: 'maddison_cond', 'proper_cond'(default). details, see vignette. root_state_weight method weigh states: 'maddison_weights','proper_weights'(default) 'equal_weights'. can also specified root state:vector c(1,0,0) indicates state 1 root state. sampling_fraction vector states sampling proportion per trait state. must many elements trait states. tol maximum tolerance. Default 'c(1e-04, 1e-05, 1e-05)'. maxiter max number iterations. Default '1000 *round((1.25)^length(idparsopt))'. optimmethod method used optimization. Available simplex subplex, default 'subplex'. Simplex used debugging. num_cycles number cycles optimization (default 1). loglik_penalty size penalty parameters; default 0 (penalty) is_complete_tree whether tree extinct species provided verbose sets verbose output; default verbose optimmethod 'simplex' num_threads number threads. Set -1 use available threads. Default one thread. atol absolute tolerance integration rtol relative tolerance integration method integration method used, available : \"odeint::runge_kutta_cash_karp54\", \"odeint::runge_kutta_fehlberg78\", \"odeint::runge_kutta_dopri5\", \"odeint::bulirsch_stoer\" \"odeint::runge_kutta4\". Default method :\"odeint::bulirsch_stoer\".","code":""},{"path":"https://rsetienne.github.io/secsse/reference/secsse_ml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maximum likehood estimation for (SecSSE) — secsse_ml","text":"Parameter estimated maximum likelihood","code":""},{"path":"https://rsetienne.github.io/secsse/reference/secsse_ml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximum likehood estimation for (SecSSE) — secsse_ml","text":"","code":"# Example of how to set the arguments for a ML search. library(secsse) library(DDD) set.seed(13) # Check the vignette for a better working exercise. # lambdas for 0A and 1A and 2A are the same but need to be estimated # mus are fixed to # the transition rates are constrained to be equal and fixed 0.01 phylotree <- ape::rcoal(31, tip.label = 1:31) traits <-  sample(c(0,1,2), ape::Ntip(phylotree),replace=TRUE)#get some traits num_concealed_states<-3 idparslist <- id_paramPos(traits, num_concealed_states) idparslist[[1]][c(1,4,7)] <- 1 idparslist[[1]][c(2,5,8)] <- 2 idparslist[[1]][c(3,6,9)] <- 3 idparslist[[2]][]<-4 masterBlock <- matrix(5,ncol = 3,nrow = 3,byrow = TRUE) diag(masterBlock) <- NA diff.conceal <- FALSE idparslist[[3]] <- q_doubletrans(traits,masterBlock,diff.conceal) startingpoint <- bd_ML(brts = ape::branching.times(phylotree)) #> You are optimizing lambda0 mu0  #> You are fixing lambda1 mu1  #> Optimizing the likelihood - this may take a while.  #> The loglikelihood for the initial parameter values is -67.5669039297515. #>  #> Maximum likelihood parameter estimates: lambda0: 15.604290, mu0: 15.874464, lambda1: 0.000000, mu1: 0.000000:  #> Maximum loglikelihood: 25.282018 intGuessLamba <- startingpoint$lambda0 intGuessMu <- startingpoint$mu0 idparsopt <- c(1,2,3,5) initparsopt <- c(rep(intGuessLamba,3),rep((intGuessLamba/5),1)) idparsfix <- c(0,4) parsfix <- c(0,0) tol <- c(1e-02, 1e-03, 1e-04) maxiter <- 1000 * round((1.25)^length(idparsopt)) optimmethod <- 'subplex' cond <- 'proper_cond' root_state_weight <- 'proper_weights' sampling_fraction <- c(1,1,1) model<-secsse_ml( phylotree, traits, num_concealed_states, idparslist, idparsopt, initparsopt, idparsfix, parsfix, cond, root_state_weight, sampling_fraction, tol, maxiter, optimmethod, num_cycles = 1, verbose = FALSE) #> Warning: You set some transitions as impossible to happen # model$ML # [1] -16.04127"},{"path":"https://rsetienne.github.io/secsse/reference/secsse_ml_func_def_pars.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum likehood estimation for (SecSSE) with parameter as complex\nfunctions. — secsse_ml_func_def_pars","title":"Maximum likehood estimation for (SecSSE) with parameter as complex\nfunctions. — secsse_ml_func_def_pars","text":"Maximum likehood estimation Several examined concealed States-dependent Speciation Extinction (SecSSE) paramaters functions parameters /factors.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/secsse_ml_func_def_pars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum likehood estimation for (SecSSE) with parameter as complex\nfunctions. — secsse_ml_func_def_pars","text":"","code":"secsse_ml_func_def_pars(   phy,   traits,   num_concealed_states,   idparslist,   idparsopt,   initparsopt,   idfactorsopt,   initfactors,   idparsfix,   parsfix,   idparsfuncdefpar,   functions_defining_params,   cond = \"proper_cond\",   root_state_weight = \"proper_weights\",   sampling_fraction,   tol = c(1e-04, 1e-05, 1e-07),   maxiter = 1000 * round((1.25)^length(idparsopt)),   optimmethod = \"simplex\",   num_cycles = 1,   loglik_penalty = 0,   is_complete_tree = FALSE,   num_threads = 1,   atol = 1e-08,   rtol = 1e-06,   method = \"odeint::bulirsch_stoer\" )"},{"path":"https://rsetienne.github.io/secsse/reference/secsse_ml_func_def_pars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum likehood estimation for (SecSSE) with parameter as complex\nfunctions. — secsse_ml_func_def_pars","text":"phy phylogenetic tree class phylo, ultrametric, rooted branch lengths. traits vector trait states tip phylogeny. num_concealed_states number concealed states, generally equivalent number examined states dataset. idparslist overview parameters values. idparsopt id parameters estimated. initparsopt initial guess parameters estimated. idfactorsopt id factors optimized. fixed factors, use constant within 'functions_defining_params'. initfactors initial guess factor (set NULL factors). idparsfix id fixed parameters (set NULL factors). parsfix value fixed parameters. idparsfuncdefpar id parameters function optimized /fixed parameters. order id match functions_defining_params functions_defining_params list functions. element function defines parameter e.g. id_3 <- (id_1+id_2)/2. See example vigenette cond condition existence node root: \"maddison_cond\",\"proper_cond\"(default). details, see vignette. root_state_weight method weigh states: \"maddison_weights\",\"proper_weights\"(default) \"equal_weights\". can also specified root state:vector c(1, 0, 0) indicates state 1 root state. sampling_fraction vector states sampling proportion per trait state. must many elements trait states. tol maximum tolerance. Default \"c(1e-04, 1e-05, 1e-05)\". maxiter max number iterations. Default \"1000 *round((1.25)^length(idparsopt))\". optimmethod method used optimization. Default \"simplex\". num_cycles number cycles optimization (default 1). loglik_penalty size penalty parameters; default 0 (penalty) is_complete_tree whether tree extinct species provided num_threads number threads. Set -1 use available threads. Default one thread. atol absolute tolerance integration rtol relative tolerance integration method integration method used, available : \"odeint::runge_kutta_cash_karp54\", \"odeint::runge_kutta_fehlberg78\", \"odeint::runge_kutta_dopri5\", \"odeint::bulirsch_stoer\" \"odeint::runge_kutta4\". Default method :\"odeint::bulirsch_stoer\".","code":""},{"path":"https://rsetienne.github.io/secsse/reference/secsse_ml_func_def_pars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maximum likehood estimation for (SecSSE) with parameter as complex\nfunctions. — secsse_ml_func_def_pars","text":"Parameter estimated maximum likelihood Parameter estimated maximum likelihood","code":""},{"path":"https://rsetienne.github.io/secsse/reference/secsse_ml_func_def_pars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximum likehood estimation for (SecSSE) with parameter as complex\nfunctions. — secsse_ml_func_def_pars","text":"","code":"# Example of how to set the arguments for a ML search. rm(list=ls(all=TRUE)) library(secsse) library(DDD) set.seed(16) phylotree <- ape::rbdtree(0.07,0.001,Tmax=50) startingpoint<-bd_ML(brts = ape::branching.times(phylotree)) #> You are optimizing lambda0 mu0  #> You are fixing lambda1 mu1  #> Optimizing the likelihood - this may take a while.  #> The loglikelihood for the initial parameter values is -106.425581129189. #>  #> Maximum likelihood parameter estimates: lambda0: 0.056537, mu0: 0.000000, lambda1: 0.000000, mu1: 0.000000:  #> Maximum loglikelihood: -104.592844 intGuessLamba <- startingpoint$lambda0 intGuessMu <- startingpoint$mu0 traits <- sample(c(0,1,2), ape::Ntip(phylotree),replace=TRUE) #get some traits num_concealed_states<-3 idparslist<-id_paramPos(traits, num_concealed_states) idparslist[[1]][c(1,4,7)] <- 1 idparslist[[1]][c(2,5,8)] <- 2 idparslist[[1]][c(3,6,9)] <- 3 idparslist[[2]][] <- 4 masterBlock <- matrix(c(5,6,5,6,5,6,5,6,5),ncol = 3,nrow = 3,byrow = TRUE) diag(masterBlock) <- NA diff.conceal <- FALSE idparslist[[3]] <- q_doubletrans(traits,masterBlock,diff.conceal) idparsfuncdefpar <- c(3,5,6) idparsopt <- c(1,2) idparsfix <- c(0,4) initparsopt <- c(rep(intGuessLamba,2)) parsfix <- c(0,0) idfactorsopt <- 1 initfactors <- 4 # functions_defining_params is a list of functions. Each function has no # arguments and to refer # to parameters ids should be indicated as \"par_\" i.e. par_3 refers to # parameter 3. When a function is defined, be sure that all the parameters # involved are either estimated, fixed or # defined by previous functions (i.e, a function that defines parameter in # 'functions_defining_params'). The user is responsible for this. In this # exampl3, par_3 (i.e., parameter 3) is needed to calculate par_6. This is # correct because par_3 is defined in # the first function of 'functions_defining_params'. Notice that factor_1 # indicates a value that will be estimated to satisfy the equation. The same # factor can be shared to define several parameters. functions_defining_params <- list() functions_defining_params[[1]] <- function(){  par_3 <- par_1 + par_2 } functions_defining_params[[2]] <- function(){  par_5 <- par_1 * factor_1 } functions_defining_params[[3]] <- function(){  par_6 <- par_3 * factor_1 }  tol = c(1e-02, 1e-03, 1e-04) maxiter = 1000 * round((1.25)^length(idparsopt)) optimmethod = \"subplex\" cond<-\"proper_cond\" root_state_weight <- \"proper_weights\" sampling_fraction <- c(1,1,1) model <- secsse_ml_func_def_pars(phylotree, traits, num_concealed_states, idparslist, idparsopt, initparsopt, idfactorsopt, initfactors, idparsfix, parsfix, idparsfuncdefpar, functions_defining_params, cond, root_state_weight, sampling_fraction, tol, maxiter, optimmethod, num_cycles = 1) #> Warning: You set some transitions as impossible to happen #> 0.0565371031208431 0.0565371031208431 4 -138.29892658976 #> Calculating the likelihood for the initial parameters. #> The loglikelihood for the initial parameter values is -138.29892658976 #> Optimizing the likelihood - this may take a while. #> 0.0565371031208431 0.0565371031208431 4 -138.29892658976 #> -19.6874997974797 0.0565371031208431 4 -Inf #> 0.0565371031208431 -19.6874997974797 4 -Inf #> 0.0565371031208431 0.0565371031208431 -2.25 -Inf #> 2.57370518668921 2.57370518668921 -0.166666666666667 -Inf #> 1.23970037744085 1.23970037744085 0.428571428571429 -Inf #> 1.23970037744085 0.0565371031208431 4 -Inf #> 0.0565371031208431 1.23970037744085 4 -408.954085121498 #> 0.0565371031208431 0.0565371031208431 -4.33333333333333 -Inf #> 0.630909092451593 0.630909092451593 0.428571428571429 -394.970765338453 #> -0.183184094316379 1.55798479466909 0.875 -Inf #> -0.0289580508740217 0.887427671713442 1.22222222222222 -Inf #> 0.435774310919359 0.0565371031208431 4 -217.435326543504 #> 0.0565371031208431 0.435774310919359 4 -215.759921685576 #> 0.282344532762055 0.282344532762055 1.22222222222222 -235.408077326566 #> 0.0565371031208431 0.056537103120843 -21 -Inf #> 0.217302799841525 0.217302799841525 2.07692307692308 -202.86182250914 #> -0.164220824193095 0.0565371031208431 4 -Inf #> 0.0565371031208431 -0.164220824193095 4 -Inf #> 0.0565371031208431 0.0565371031208431 1.22222222222222 -140.359130113342 #> -0.101652478250067 0.435774310919359 1.72727272727273 -Inf #> -0.0667186885311693 0.217302799841525 2.07692307692308 -Inf #> -0.0667186885311693 0.0565371031208431 4 -Inf #> 0.0565371031208431 -0.0667186885311693 4 -Inf #> 0.0565371031208431 0.0565371031208431 2.07692307692308 -139.142155325368 #> -0.0289580508740217 0.217302799841525 2.52941176470588 -Inf #> -0.00890822400049493 0.13123669972533 2.80952380952381 -Inf #> -0.00890822400049493 0.0565371031208431 4 -Inf #> 0.0565371031208431 -0.00890822400049493 4 -Inf #> 0.0565371031208431 0.0565371031208431 2.80952380952381 -138.67921314246 #> 0.13123669972533 0.0565371031208431 4 -147.961630608301 #> 0.0565371031208431 0.13123669972533 4 -148.307993814251 #> 0.0565371031208431 0.0565371031208431 6.27272727272728 -138.007331731512 #> 0.105190205544315 -0.00890822400049493 5.31578947368422 -Inf #> 0.0682943175325757 0.0926116256780313 4.27472527472528 -143.832954528161 #> -0.00203968049049697 0.0803161467061682 5.60550458715597 -Inf #> 0.0946881343274375 0.0623831825484161 4.32347504621072 -143.090390803217 #> 0.0696168471619277 0.0264136556123879 5.22478386167147 -136.921872814753 #> 0.0702793406885307 -0.00376572610556988 5.84085510688836 -Inf #> 0.0290624149289556 0.0306992264027016 5.93233484889008 -138.621348872489 #> 0.0447199562294352 0.0384417109814988 5.44535621036927 -136.933297942811 #> 0.0571834882945641 0.0245878726542851 8.78482446206113 -136.628875452395 #> 0.0575069775640771 0.00932706313748703 17.7622149837132 -137.320525917318 #> 0.0576148513184024 0.00434065127435459 6.08390270565726 -137.660662938957 #> 0.0573452081868561 0.01690021567186 6.13018361873322 -136.854746501097 #> 0.0785180903673741 0.00726785049012128 7.80434782608691 -136.66692497088 #> 0.0589471061052005 0.00619256503065626 12.0371363903092 -137.452222887806 #> 0.0669293051341006 0.0212825683726463 6.16013858035703 -136.672632060038 #> 0.0777955629677048 0.0184151658513158 9.33996720003544 -136.875767566307 #> 0.0623846944917256 0.0172785305143808 6.73008650701768 -136.669341578847 #> 0.0649759220488105 0.0114221191842328 10.0578020753919 -136.754385324718 #> 0.0664402878763672 0.0187994754408668 6.85206414499345 -136.62941971293 #> 0.0722796266989215 0.0163897753025553 9.06121371968436 -136.664259288779 #> 0.0523333066096938 0.0328819777396786 8.45922624799519 -136.644991100937 #> 0.0571834882945641 0.0245878726542851 10.5508021390374 -136.61329407849 #> 0.0571834882945641 0.00844351337212945 8.78482446206113 -137.355370383151 #> 0.0749398740088071 0.0245878726542851 8.78482446206113 -137.000930185751 #> 0.068955173283337 0.0412575580652741 9.89533417402267 -137.62465214392 #> 0.060102036129208 0.0164515916081767 9.04067402672863 -136.731129320048 #> 0.0418853769445456 0.0191492893092306 10.1053984575835 -137.888330604895 #> 0.0664811703227776 0.0232227923625168 9.08462211847093 -136.661966791511 #> 0.0604273142411855 0.0319302561674392 9.82706766917288 -136.710722399657 #> 0.0603459760007705 0.0280165617887137 9.61914272545702 -136.632090775921 #> 0.0501164607402297 0.0282459571605786 10.1772315653298 -136.685285960957 #> 0.0623423617057083 0.0244739768629935 9.33724669109395 -136.618106435315 #> 0.0574530489386094 0.0211065491733346 9.39815464848055 -136.67481972123 #> 0.0596212613135387 0.0262803056984378 9.56301975217448 -136.609547399912 #> 0.0622516599521428 0.0256394398772377 11.0305172263747 -136.618678751559 #> 0.0609800668078614 0.0253763457627227 10.3776997414283 -136.606982053466 #> 0.0561940323902956 0.0263565014061938 11.0939591443943 -136.601916434086 #> 0.0531464784189513 0.0273003604917051 12.2170088677485 -136.620072375956 #> 0.0561940323902956 0.0263565014061938 11.6936320646434 -136.598657837232 #> 0.0561940323902956 0.0304879388893961 11.0939591443943 -136.601797973284 #> 0.0518543360127933 0.0263565014061938 11.0939591443943 -136.67522313991 #> 0.0605696861929951 0.0291071023570987 11.4872408653628 -136.638485430601 #> 0.0583773367400651 0.0284180708851324 11.3865418216029 -136.601123650355 #> 0.0576485663801091 0.0304879388893961 11.6936320646434 -136.611870687239 #> 0.0565572906928047 0.0273862519522353 11.2385020583417 -136.593935947306 #> 0.0578913782940932 0.0243031806466864 11.7994074348409 -136.603654137303 #> 0.056617858037715 0.0289347579451092 11.2629291226824 -136.594303984702 #> 0.0545423449410474 0.0266995221514903 11.4032120586783 -136.613573793234 #> 0.0574159761990854 0.0279878945637536 11.3907051784793 -136.593337698077 #> 0.0575339439395769 0.029854595782983 10.9244371603553 -136.609229071358 #> 0.0565286918602074 0.0272287952443322 11.4921777044809 -136.592899600194 #> 0.057049882100307 0.0261374692352738 11.4848913607935 -136.596049082943 #> 0.05672583094284 0.0282340069577987 11.3176764761025 -136.592637544749 # ML -136.5796"},{"path":"https://rsetienne.github.io/secsse/reference/secsse_sim.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to simulate a tree, conditional on observing all states. — secsse_sim","title":"Function to simulate a tree, conditional on observing all states. — secsse_sim","text":"default, secsse_sim assumes CLA-secsse simulation, e.g. inheritance traits speciation need symmetrical, can specified usage lambda-matrices. Hence, input lambdas typically list matrices. Simulation performed randomly sampled initial trait crown - , however - want specific, single, trait used crown, can reduce possible traits modifying 'pool_init_states'. default, algorithm keeps simulating generates tree crown lineages survive present - ensure tree crown age matches used crown age. can modify 'non-extinction' deviate behaviour.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/secsse_sim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to simulate a tree, conditional on observing all states. — secsse_sim","text":"","code":"secsse_sim(   lambdas,   mus,   qs,   crown_age,   num_concealed_states,   pool_init_states = NULL,   maxSpec = 1e+05,   conditioning = \"none\",   non_extinction = TRUE,   verbose = FALSE,   max_tries = 1e+06,   drop_extinct = TRUE,   seed = NULL )"},{"path":"https://rsetienne.github.io/secsse/reference/secsse_sim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to simulate a tree, conditional on observing all states. — secsse_sim","text":"lambdas speciation rates, form list matrices mus extinction rates, form vector qs Q matrix, example result function q_doubletrans, generally form matrix. crown_age crown age tree, tree simulated conditional non-extinction crown age. num_concealed_states number concealed states pool_init_states pool initial states crown, case different available states, otherwise leave NULL maxSpec Maximum number species tree (please note tree conditioned number, safeguard generating extremely large trees). conditioning can 'obs_states', 'true_states' 'none', tree simulated one generated contains observed states ('obs_states'), true states (e.g. combinations obs hidden states), always returned ('none'). non_extinction tree conditioned non-extinction crown lineages? Default TRUE. verbose provide intermediate output. max_tries maximum number simulations try obtain tree. drop_extinct extinct species dropped tree? default TRUE. seed pseudo-random number generator seed","code":""},{"path":"https://rsetienne.github.io/secsse/reference/secsse_sim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to simulate a tree, conditional on observing all states. — secsse_sim","text":"list four properties: phy: reconstructed phylogeny, true_traits: true traits order tip label, obs_traits: observed traits, ignoring hidden traits lastly: initialState, delineating initial state root used.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/sortingtraits.html","id":null,"dir":"Reference","previous_headings":"","what":"Data checking and trait sorting — sortingtraits","title":"Data checking and trait sorting — sortingtraits","text":"preparation likelihood calculation, orders trait data according tree tips","code":""},{"path":"https://rsetienne.github.io/secsse/reference/sortingtraits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data checking and trait sorting — sortingtraits","text":"","code":"sortingtraits(traitinfo, phy)"},{"path":"https://rsetienne.github.io/secsse/reference/sortingtraits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data checking and trait sorting — sortingtraits","text":"traitinfo data frame first column species ids second one trait associated information. phy phy phylogenetic tree class phylo, ultrametric, fully-resolved, rooted branch lengths.","code":""},{"path":"https://rsetienne.github.io/secsse/reference/sortingtraits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Data checking and trait sorting — sortingtraits","text":"Vector traits","code":""},{"path":"https://rsetienne.github.io/secsse/reference/sortingtraits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data checking and trait sorting — sortingtraits","text":"","code":"# Some data we have prepared data(traitinfo) data('phylo_Vign') traits <- sortingtraits(traitinfo,phylo_Vign)"},{"path":"https://rsetienne.github.io/secsse/reference/traitinfo.html","id":null,"dir":"Reference","previous_headings":"","what":"A table with trait info to run the vignette — traitinfo","title":"A table with trait info to run the vignette — traitinfo","text":"example trait information right format secsse","code":""},{"path":"https://rsetienne.github.io/secsse/reference/traitinfo.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A table with trait info to run the vignette — traitinfo","text":"data frame species trait state associated","code":""}]
